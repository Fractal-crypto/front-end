{
  "version": 3,
  "sources": ["../zrender/lib/canvas/helper.js", "../zrender/lib/canvas/dashStyle.js", "../zrender/lib/canvas/graphic.js", "../zrender/lib/animation/requestAnimationFrame.js"],
  "sourcesContent": ["export function createLinearGradient(ctx, obj, rect) {\n    var x = obj.x == null ? 0 : obj.x;\n    var x2 = obj.x2 == null ? 1 : obj.x2;\n    var y = obj.y == null ? 0 : obj.y;\n    var y2 = obj.y2 == null ? 0 : obj.y2;\n    if (!obj.global) {\n        x = x * rect.width + rect.x;\n        x2 = x2 * rect.width + rect.x;\n        y = y * rect.height + rect.y;\n        y2 = y2 * rect.height + rect.y;\n    }\n    x = isNaN(x) ? 0 : x;\n    x2 = isNaN(x2) ? 1 : x2;\n    y = isNaN(y) ? 0 : y;\n    y2 = isNaN(y2) ? 0 : y2;\n    var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n    return canvasGradient;\n}\nexport function createRadialGradient(ctx, obj, rect) {\n    var width = rect.width;\n    var height = rect.height;\n    var min = Math.min(width, height);\n    var x = obj.x == null ? 0.5 : obj.x;\n    var y = obj.y == null ? 0.5 : obj.y;\n    var r = obj.r == null ? 0.5 : obj.r;\n    if (!obj.global) {\n        x = x * width + rect.x;\n        y = y * height + rect.y;\n        r = r * min;\n    }\n    var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n    return canvasGradient;\n}\nexport function getCanvasGradient(ctx, obj, rect) {\n    var canvasGradient = obj.type === 'radial'\n        ? createRadialGradient(ctx, obj, rect)\n        : createLinearGradient(ctx, obj, rect);\n    var colorStops = obj.colorStops;\n    for (var i = 0; i < colorStops.length; i++) {\n        canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n    }\n    return canvasGradient;\n}\nexport function isClipPathChanged(clipPaths, prevClipPaths) {\n    if (clipPaths === prevClipPaths || (!clipPaths && !prevClipPaths)) {\n        return false;\n    }\n    if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n        return true;\n    }\n    for (var i = 0; i < clipPaths.length; i++) {\n        if (clipPaths[i] !== prevClipPaths[i]) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction parseInt10(val) {\n    return parseInt(val, 10);\n}\nexport function getSize(root, whIdx, opts) {\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n        return parseFloat(opts[wh]);\n    }\n    var stl = document.defaultView.getComputedStyle(root);\n    return ((root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n        - (parseInt10(stl[plt]) || 0)\n        - (parseInt10(stl[prb]) || 0)) | 0;\n}\n", "import { isArray, isNumber, map } from '../core/util.js';\nexport function normalizeLineDash(lineType, lineWidth) {\n    if (!lineType || lineType === 'solid' || !(lineWidth > 0)) {\n        return null;\n    }\n    return lineType === 'dashed'\n        ? [4 * lineWidth, 2 * lineWidth]\n        : lineType === 'dotted'\n            ? [lineWidth]\n            : isNumber(lineType)\n                ? [lineType] : isArray(lineType) ? lineType : null;\n}\nexport function getLineDash(el) {\n    var style = el.style;\n    var lineDash = style.lineDash && style.lineWidth > 0 && normalizeLineDash(style.lineDash, style.lineWidth);\n    var lineDashOffset = style.lineDashOffset;\n    if (lineDash) {\n        var lineScale_1 = (style.strokeNoScale && el.getLineScale) ? el.getLineScale() : 1;\n        if (lineScale_1 && lineScale_1 !== 1) {\n            lineDash = map(lineDash, function (rawVal) {\n                return rawVal / lineScale_1;\n            });\n            lineDashOffset /= lineScale_1;\n        }\n    }\n    return [lineDash, lineDashOffset];\n}\n", "import { DEFAULT_COMMON_STYLE } from '../graphic/Displayable.js';\nimport PathProxy from '../core/PathProxy.js';\nimport { createOrUpdateImage, isImageReady } from '../graphic/helper/image.js';\nimport { getCanvasGradient, isClipPathChanged } from './helper.js';\nimport Path from '../graphic/Path.js';\nimport ZRImage from '../graphic/Image.js';\nimport TSpan from '../graphic/TSpan.js';\nimport { RADIAN_TO_DEGREE } from '../core/util.js';\nimport { getLineDash } from './dashStyle.js';\nimport { REDRAW_BIT, SHAPE_CHANGED_BIT } from '../graphic/constants.js';\nimport { DEFAULT_FONT } from '../core/platform.js';\nvar pathProxyForDraw = new PathProxy(true);\nfunction styleHasStroke(style) {\n    var stroke = style.stroke;\n    return !(stroke == null || stroke === 'none' || !(style.lineWidth > 0));\n}\nfunction isValidStrokeFillStyle(strokeOrFill) {\n    return typeof strokeOrFill === 'string' && strokeOrFill !== 'none';\n}\nfunction styleHasFill(style) {\n    var fill = style.fill;\n    return fill != null && fill !== 'none';\n}\nfunction doFillPath(ctx, style) {\n    if (style.fillOpacity != null && style.fillOpacity !== 1) {\n        var originalGlobalAlpha = ctx.globalAlpha;\n        ctx.globalAlpha = style.fillOpacity * style.opacity;\n        ctx.fill();\n        ctx.globalAlpha = originalGlobalAlpha;\n    }\n    else {\n        ctx.fill();\n    }\n}\nfunction doStrokePath(ctx, style) {\n    if (style.strokeOpacity != null && style.strokeOpacity !== 1) {\n        var originalGlobalAlpha = ctx.globalAlpha;\n        ctx.globalAlpha = style.strokeOpacity * style.opacity;\n        ctx.stroke();\n        ctx.globalAlpha = originalGlobalAlpha;\n    }\n    else {\n        ctx.stroke();\n    }\n}\nexport function createCanvasPattern(ctx, pattern, el) {\n    var image = createOrUpdateImage(pattern.image, pattern.__image, el);\n    if (isImageReady(image)) {\n        var canvasPattern = ctx.createPattern(image, pattern.repeat || 'repeat');\n        if (typeof DOMMatrix === 'function'\n            && canvasPattern\n            && canvasPattern.setTransform) {\n            var matrix = new DOMMatrix();\n            matrix.translateSelf((pattern.x || 0), (pattern.y || 0));\n            matrix.rotateSelf(0, 0, (pattern.rotation || 0) * RADIAN_TO_DEGREE);\n            matrix.scaleSelf((pattern.scaleX || 1), (pattern.scaleY || 1));\n            canvasPattern.setTransform(matrix);\n        }\n        return canvasPattern;\n    }\n}\nfunction brushPath(ctx, el, style, inBatch) {\n    var _a;\n    var hasStroke = styleHasStroke(style);\n    var hasFill = styleHasFill(style);\n    var strokePercent = style.strokePercent;\n    var strokePart = strokePercent < 1;\n    var firstDraw = !el.path;\n    if ((!el.silent || strokePart) && firstDraw) {\n        el.createPathProxy();\n    }\n    var path = el.path || pathProxyForDraw;\n    var dirtyFlag = el.__dirty;\n    if (!inBatch) {\n        var fill = style.fill;\n        var stroke = style.stroke;\n        var hasFillGradient = hasFill && !!fill.colorStops;\n        var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n        var hasFillPattern = hasFill && !!fill.image;\n        var hasStrokePattern = hasStroke && !!stroke.image;\n        var fillGradient = void 0;\n        var strokeGradient = void 0;\n        var fillPattern = void 0;\n        var strokePattern = void 0;\n        var rect = void 0;\n        if (hasFillGradient || hasStrokeGradient) {\n            rect = el.getBoundingRect();\n        }\n        if (hasFillGradient) {\n            fillGradient = dirtyFlag\n                ? getCanvasGradient(ctx, fill, rect)\n                : el.__canvasFillGradient;\n            el.__canvasFillGradient = fillGradient;\n        }\n        if (hasStrokeGradient) {\n            strokeGradient = dirtyFlag\n                ? getCanvasGradient(ctx, stroke, rect)\n                : el.__canvasStrokeGradient;\n            el.__canvasStrokeGradient = strokeGradient;\n        }\n        if (hasFillPattern) {\n            fillPattern = (dirtyFlag || !el.__canvasFillPattern)\n                ? createCanvasPattern(ctx, fill, el)\n                : el.__canvasFillPattern;\n            el.__canvasFillPattern = fillPattern;\n        }\n        if (hasStrokePattern) {\n            strokePattern = (dirtyFlag || !el.__canvasStrokePattern)\n                ? createCanvasPattern(ctx, stroke, el)\n                : el.__canvasStrokePattern;\n            el.__canvasStrokePattern = fillPattern;\n        }\n        if (hasFillGradient) {\n            ctx.fillStyle = fillGradient;\n        }\n        else if (hasFillPattern) {\n            if (fillPattern) {\n                ctx.fillStyle = fillPattern;\n            }\n            else {\n                hasFill = false;\n            }\n        }\n        if (hasStrokeGradient) {\n            ctx.strokeStyle = strokeGradient;\n        }\n        else if (hasStrokePattern) {\n            if (strokePattern) {\n                ctx.strokeStyle = strokePattern;\n            }\n            else {\n                hasStroke = false;\n            }\n        }\n    }\n    var scale = el.getGlobalScale();\n    path.setScale(scale[0], scale[1], el.segmentIgnoreThreshold);\n    var lineDash;\n    var lineDashOffset;\n    if (ctx.setLineDash && style.lineDash) {\n        _a = getLineDash(el), lineDash = _a[0], lineDashOffset = _a[1];\n    }\n    var needsRebuild = true;\n    if (firstDraw || (dirtyFlag & SHAPE_CHANGED_BIT)) {\n        path.setDPR(ctx.dpr);\n        if (strokePart) {\n            path.setContext(null);\n        }\n        else {\n            path.setContext(ctx);\n            needsRebuild = false;\n        }\n        path.reset();\n        el.buildPath(path, el.shape, inBatch);\n        path.toStatic();\n        el.pathUpdated();\n    }\n    if (needsRebuild) {\n        path.rebuildPath(ctx, strokePart ? strokePercent : 1);\n    }\n    if (lineDash) {\n        ctx.setLineDash(lineDash);\n        ctx.lineDashOffset = lineDashOffset;\n    }\n    if (!inBatch) {\n        if (style.strokeFirst) {\n            if (hasStroke) {\n                doStrokePath(ctx, style);\n            }\n            if (hasFill) {\n                doFillPath(ctx, style);\n            }\n        }\n        else {\n            if (hasFill) {\n                doFillPath(ctx, style);\n            }\n            if (hasStroke) {\n                doStrokePath(ctx, style);\n            }\n        }\n    }\n    if (lineDash) {\n        ctx.setLineDash([]);\n    }\n}\nfunction brushImage(ctx, el, style) {\n    var image = el.__image = createOrUpdateImage(style.image, el.__image, el, el.onload);\n    if (!image || !isImageReady(image)) {\n        return;\n    }\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var width = el.getWidth();\n    var height = el.getHeight();\n    var aspect = image.width / image.height;\n    if (width == null && height != null) {\n        width = height * aspect;\n    }\n    else if (height == null && width != null) {\n        height = width / aspect;\n    }\n    else if (width == null && height == null) {\n        width = image.width;\n        height = image.height;\n    }\n    if (style.sWidth && style.sHeight) {\n        var sx = style.sx || 0;\n        var sy = style.sy || 0;\n        ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n    }\n    else if (style.sx && style.sy) {\n        var sx = style.sx;\n        var sy = style.sy;\n        var sWidth = width - sx;\n        var sHeight = height - sy;\n        ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n    }\n    else {\n        ctx.drawImage(image, x, y, width, height);\n    }\n}\nfunction brushText(ctx, el, style) {\n    var _a;\n    var text = style.text;\n    text != null && (text += '');\n    if (text) {\n        ctx.font = style.font || DEFAULT_FONT;\n        ctx.textAlign = style.textAlign;\n        ctx.textBaseline = style.textBaseline;\n        var lineDash = void 0;\n        var lineDashOffset = void 0;\n        if (ctx.setLineDash && style.lineDash) {\n            _a = getLineDash(el), lineDash = _a[0], lineDashOffset = _a[1];\n        }\n        if (lineDash) {\n            ctx.setLineDash(lineDash);\n            ctx.lineDashOffset = lineDashOffset;\n        }\n        if (style.strokeFirst) {\n            if (styleHasStroke(style)) {\n                ctx.strokeText(text, style.x, style.y);\n            }\n            if (styleHasFill(style)) {\n                ctx.fillText(text, style.x, style.y);\n            }\n        }\n        else {\n            if (styleHasFill(style)) {\n                ctx.fillText(text, style.x, style.y);\n            }\n            if (styleHasStroke(style)) {\n                ctx.strokeText(text, style.x, style.y);\n            }\n        }\n        if (lineDash) {\n            ctx.setLineDash([]);\n        }\n    }\n}\nvar SHADOW_NUMBER_PROPS = ['shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];\nvar STROKE_PROPS = [\n    ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n];\nfunction bindCommonProps(ctx, style, prevStyle, forceSetAll, scope) {\n    var styleChanged = false;\n    if (!forceSetAll) {\n        prevStyle = prevStyle || {};\n        if (style === prevStyle) {\n            return false;\n        }\n    }\n    if (forceSetAll || style.opacity !== prevStyle.opacity) {\n        flushPathDrawn(ctx, scope);\n        styleChanged = true;\n        var opacity = Math.max(Math.min(style.opacity, 1), 0);\n        ctx.globalAlpha = isNaN(opacity) ? DEFAULT_COMMON_STYLE.opacity : opacity;\n    }\n    if (forceSetAll || style.blend !== prevStyle.blend) {\n        if (!styleChanged) {\n            flushPathDrawn(ctx, scope);\n            styleChanged = true;\n        }\n        ctx.globalCompositeOperation = style.blend || DEFAULT_COMMON_STYLE.blend;\n    }\n    for (var i = 0; i < SHADOW_NUMBER_PROPS.length; i++) {\n        var propName = SHADOW_NUMBER_PROPS[i];\n        if (forceSetAll || style[propName] !== prevStyle[propName]) {\n            if (!styleChanged) {\n                flushPathDrawn(ctx, scope);\n                styleChanged = true;\n            }\n            ctx[propName] = ctx.dpr * (style[propName] || 0);\n        }\n    }\n    if (forceSetAll || style.shadowColor !== prevStyle.shadowColor) {\n        if (!styleChanged) {\n            flushPathDrawn(ctx, scope);\n            styleChanged = true;\n        }\n        ctx.shadowColor = style.shadowColor || DEFAULT_COMMON_STYLE.shadowColor;\n    }\n    return styleChanged;\n}\nfunction bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetAll, scope) {\n    var style = getStyle(el, scope.inHover);\n    var prevStyle = forceSetAll\n        ? null\n        : (prevEl && getStyle(prevEl, scope.inHover) || {});\n    if (style === prevStyle) {\n        return false;\n    }\n    var styleChanged = bindCommonProps(ctx, style, prevStyle, forceSetAll, scope);\n    if (forceSetAll || style.fill !== prevStyle.fill) {\n        if (!styleChanged) {\n            flushPathDrawn(ctx, scope);\n            styleChanged = true;\n        }\n        isValidStrokeFillStyle(style.fill) && (ctx.fillStyle = style.fill);\n    }\n    if (forceSetAll || style.stroke !== prevStyle.stroke) {\n        if (!styleChanged) {\n            flushPathDrawn(ctx, scope);\n            styleChanged = true;\n        }\n        isValidStrokeFillStyle(style.stroke) && (ctx.strokeStyle = style.stroke);\n    }\n    if (forceSetAll || style.opacity !== prevStyle.opacity) {\n        if (!styleChanged) {\n            flushPathDrawn(ctx, scope);\n            styleChanged = true;\n        }\n        ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n    }\n    if (el.hasStroke()) {\n        var lineWidth = style.lineWidth;\n        var newLineWidth = lineWidth / ((style.strokeNoScale && el.getLineScale) ? el.getLineScale() : 1);\n        if (ctx.lineWidth !== newLineWidth) {\n            if (!styleChanged) {\n                flushPathDrawn(ctx, scope);\n                styleChanged = true;\n            }\n            ctx.lineWidth = newLineWidth;\n        }\n    }\n    for (var i = 0; i < STROKE_PROPS.length; i++) {\n        var prop = STROKE_PROPS[i];\n        var propName = prop[0];\n        if (forceSetAll || style[propName] !== prevStyle[propName]) {\n            if (!styleChanged) {\n                flushPathDrawn(ctx, scope);\n                styleChanged = true;\n            }\n            ctx[propName] = style[propName] || prop[1];\n        }\n    }\n    return styleChanged;\n}\nfunction bindImageStyle(ctx, el, prevEl, forceSetAll, scope) {\n    return bindCommonProps(ctx, getStyle(el, scope.inHover), prevEl && getStyle(prevEl, scope.inHover), forceSetAll, scope);\n}\nfunction setContextTransform(ctx, el) {\n    var m = el.transform;\n    var dpr = ctx.dpr || 1;\n    if (m) {\n        ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n    }\n    else {\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    }\n}\nfunction updateClipStatus(clipPaths, ctx, scope) {\n    var allClipped = false;\n    for (var i = 0; i < clipPaths.length; i++) {\n        var clipPath = clipPaths[i];\n        allClipped = allClipped || clipPath.isZeroArea();\n        setContextTransform(ctx, clipPath);\n        ctx.beginPath();\n        clipPath.buildPath(ctx, clipPath.shape);\n        ctx.clip();\n    }\n    scope.allClipped = allClipped;\n}\nfunction isTransformChanged(m0, m1) {\n    if (m0 && m1) {\n        return m0[0] !== m1[0]\n            || m0[1] !== m1[1]\n            || m0[2] !== m1[2]\n            || m0[3] !== m1[3]\n            || m0[4] !== m1[4]\n            || m0[5] !== m1[5];\n    }\n    else if (!m0 && !m1) {\n        return false;\n    }\n    return true;\n}\nvar DRAW_TYPE_PATH = 1;\nvar DRAW_TYPE_IMAGE = 2;\nvar DRAW_TYPE_TEXT = 3;\nvar DRAW_TYPE_INCREMENTAL = 4;\nfunction canPathBatch(style) {\n    var hasFill = styleHasFill(style);\n    var hasStroke = styleHasStroke(style);\n    return !(style.lineDash\n        || !(+hasFill ^ +hasStroke)\n        || (hasFill && typeof style.fill !== 'string')\n        || (hasStroke && typeof style.stroke !== 'string')\n        || style.strokePercent < 1\n        || style.strokeOpacity < 1\n        || style.fillOpacity < 1);\n}\nfunction flushPathDrawn(ctx, scope) {\n    scope.batchFill && ctx.fill();\n    scope.batchStroke && ctx.stroke();\n    scope.batchFill = '';\n    scope.batchStroke = '';\n}\nfunction getStyle(el, inHover) {\n    return inHover ? (el.__hoverStyle || el.style) : el.style;\n}\nexport function brushSingle(ctx, el) {\n    brush(ctx, el, { inHover: false, viewWidth: 0, viewHeight: 0 }, true);\n}\nexport function brush(ctx, el, scope, isLast) {\n    var m = el.transform;\n    if (!el.shouldBePainted(scope.viewWidth, scope.viewHeight, false, false)) {\n        el.__dirty &= ~REDRAW_BIT;\n        el.__isRendered = false;\n        return;\n    }\n    var clipPaths = el.__clipPaths;\n    var prevElClipPaths = scope.prevElClipPaths;\n    var forceSetTransform = false;\n    var forceSetStyle = false;\n    if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {\n        if (prevElClipPaths && prevElClipPaths.length) {\n            flushPathDrawn(ctx, scope);\n            ctx.restore();\n            forceSetStyle = forceSetTransform = true;\n            scope.prevElClipPaths = null;\n            scope.allClipped = false;\n            scope.prevEl = null;\n        }\n        if (clipPaths && clipPaths.length) {\n            flushPathDrawn(ctx, scope);\n            ctx.save();\n            updateClipStatus(clipPaths, ctx, scope);\n            forceSetTransform = true;\n        }\n        scope.prevElClipPaths = clipPaths;\n    }\n    if (scope.allClipped) {\n        el.__isRendered = false;\n        return;\n    }\n    el.beforeBrush && el.beforeBrush();\n    el.innerBeforeBrush();\n    var prevEl = scope.prevEl;\n    if (!prevEl) {\n        forceSetStyle = forceSetTransform = true;\n    }\n    var canBatchPath = el instanceof Path\n        && el.autoBatch\n        && canPathBatch(el.style);\n    if (forceSetTransform || isTransformChanged(m, prevEl.transform)) {\n        flushPathDrawn(ctx, scope);\n        setContextTransform(ctx, el);\n    }\n    else if (!canBatchPath) {\n        flushPathDrawn(ctx, scope);\n    }\n    var style = getStyle(el, scope.inHover);\n    if (el instanceof Path) {\n        if (scope.lastDrawType !== DRAW_TYPE_PATH) {\n            forceSetStyle = true;\n            scope.lastDrawType = DRAW_TYPE_PATH;\n        }\n        bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);\n        if (!canBatchPath || (!scope.batchFill && !scope.batchStroke)) {\n            ctx.beginPath();\n        }\n        brushPath(ctx, el, style, canBatchPath);\n        if (canBatchPath) {\n            scope.batchFill = style.fill || '';\n            scope.batchStroke = style.stroke || '';\n        }\n    }\n    else {\n        if (el instanceof TSpan) {\n            if (scope.lastDrawType !== DRAW_TYPE_TEXT) {\n                forceSetStyle = true;\n                scope.lastDrawType = DRAW_TYPE_TEXT;\n            }\n            bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);\n            brushText(ctx, el, style);\n        }\n        else if (el instanceof ZRImage) {\n            if (scope.lastDrawType !== DRAW_TYPE_IMAGE) {\n                forceSetStyle = true;\n                scope.lastDrawType = DRAW_TYPE_IMAGE;\n            }\n            bindImageStyle(ctx, el, prevEl, forceSetStyle, scope);\n            brushImage(ctx, el, style);\n        }\n        else if (el.getTemporalDisplayables) {\n            if (scope.lastDrawType !== DRAW_TYPE_INCREMENTAL) {\n                forceSetStyle = true;\n                scope.lastDrawType = DRAW_TYPE_INCREMENTAL;\n            }\n            brushIncremental(ctx, el, scope);\n        }\n    }\n    if (canBatchPath && isLast) {\n        flushPathDrawn(ctx, scope);\n    }\n    el.innerAfterBrush();\n    el.afterBrush && el.afterBrush();\n    scope.prevEl = el;\n    el.__dirty = 0;\n    el.__isRendered = true;\n}\nfunction brushIncremental(ctx, el, scope) {\n    var displayables = el.getDisplayables();\n    var temporalDisplayables = el.getTemporalDisplayables();\n    ctx.save();\n    var innerScope = {\n        prevElClipPaths: null,\n        prevEl: null,\n        allClipped: false,\n        viewWidth: scope.viewWidth,\n        viewHeight: scope.viewHeight,\n        inHover: scope.inHover\n    };\n    var i;\n    var len;\n    for (i = el.getCursor(), len = displayables.length; i < len; i++) {\n        var displayable = displayables[i];\n        displayable.beforeBrush && displayable.beforeBrush();\n        displayable.innerBeforeBrush();\n        brush(ctx, displayable, innerScope, i === len - 1);\n        displayable.innerAfterBrush();\n        displayable.afterBrush && displayable.afterBrush();\n        innerScope.prevEl = displayable;\n    }\n    for (var i_1 = 0, len_1 = temporalDisplayables.length; i_1 < len_1; i_1++) {\n        var displayable = temporalDisplayables[i_1];\n        displayable.beforeBrush && displayable.beforeBrush();\n        displayable.innerBeforeBrush();\n        brush(ctx, displayable, innerScope, i_1 === len_1 - 1);\n        displayable.innerAfterBrush();\n        displayable.afterBrush && displayable.afterBrush();\n        innerScope.prevEl = displayable;\n    }\n    el.clearTemporalDisplayables();\n    el.notClear = true;\n    ctx.restore();\n}\n", "import env from '../core/env.js';\nvar requestAnimationFrame;\nrequestAnimationFrame = (env.hasGlobalWindow\n    && ((window.requestAnimationFrame && window.requestAnimationFrame.bind(window))\n        || (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window))\n        || window.mozRequestAnimationFrame\n        || window.webkitRequestAnimationFrame)) || function (func) {\n    return setTimeout(func, 16);\n};\nexport default requestAnimationFrame;\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAO,8BAA8B,KAAK,KAAK,MAAM;AACjD,MAAI,IAAI,IAAI,KAAK,OAAO,IAAI,IAAI;AAChC,MAAI,KAAK,IAAI,MAAM,OAAO,IAAI,IAAI;AAClC,MAAI,IAAI,IAAI,KAAK,OAAO,IAAI,IAAI;AAChC,MAAI,KAAK,IAAI,MAAM,OAAO,IAAI,IAAI;AAClC,MAAI,CAAC,IAAI,QAAQ;AACb,QAAI,IAAI,KAAK,QAAQ,KAAK;AAC1B,SAAK,KAAK,KAAK,QAAQ,KAAK;AAC5B,QAAI,IAAI,KAAK,SAAS,KAAK;AAC3B,SAAK,KAAK,KAAK,SAAS,KAAK;AAAA;AAEjC,MAAI,MAAM,KAAK,IAAI;AACnB,OAAK,MAAM,MAAM,IAAI;AACrB,MAAI,MAAM,KAAK,IAAI;AACnB,OAAK,MAAM,MAAM,IAAI;AACrB,MAAI,iBAAiB,IAAI,qBAAqB,GAAG,GAAG,IAAI;AACxD,SAAO;AAAA;AAEJ,8BAA8B,KAAK,KAAK,MAAM;AACjD,MAAI,QAAQ,KAAK;AACjB,MAAI,SAAS,KAAK;AAClB,MAAI,MAAM,KAAK,IAAI,OAAO;AAC1B,MAAI,IAAI,IAAI,KAAK,OAAO,MAAM,IAAI;AAClC,MAAI,IAAI,IAAI,KAAK,OAAO,MAAM,IAAI;AAClC,MAAI,IAAI,IAAI,KAAK,OAAO,MAAM,IAAI;AAClC,MAAI,CAAC,IAAI,QAAQ;AACb,QAAI,IAAI,QAAQ,KAAK;AACrB,QAAI,IAAI,SAAS,KAAK;AACtB,QAAI,IAAI;AAAA;AAEZ,MAAI,iBAAiB,IAAI,qBAAqB,GAAG,GAAG,GAAG,GAAG,GAAG;AAC7D,SAAO;AAAA;AAEJ,2BAA2B,KAAK,KAAK,MAAM;AAC9C,MAAI,iBAAiB,IAAI,SAAS,WAC5B,qBAAqB,KAAK,KAAK,QAC/B,qBAAqB,KAAK,KAAK;AACrC,MAAI,aAAa,IAAI;AACrB,WAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AACxC,mBAAe,aAAa,WAAW,GAAG,QAAQ,WAAW,GAAG;AAAA;AAEpE,SAAO;AAAA;AAEJ,2BAA2B,WAAW,eAAe;AACxD,MAAI,cAAc,iBAAkB,CAAC,aAAa,CAAC,eAAgB;AAC/D,WAAO;AAAA;AAEX,MAAI,CAAC,aAAa,CAAC,iBAAkB,UAAU,WAAW,cAAc,QAAS;AAC7E,WAAO;AAAA;AAEX,WAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACvC,QAAI,UAAU,OAAO,cAAc,IAAI;AACnC,aAAO;AAAA;AAAA;AAGf,SAAO;AAAA;AAEX,oBAAoB,KAAK;AACrB,SAAO,SAAS,KAAK;AAAA;AAElB,iBAAiB,MAAM,OAAO,MAAM;AACvC,MAAI,KAAK,CAAC,SAAS,UAAU;AAC7B,MAAI,MAAM,CAAC,eAAe,gBAAgB;AAC1C,MAAI,MAAM,CAAC,eAAe,cAAc;AACxC,MAAI,MAAM,CAAC,gBAAgB,iBAAiB;AAC5C,MAAI,KAAK,OAAO,QAAQ,KAAK,QAAQ,QAAQ;AACzC,WAAO,WAAW,KAAK;AAAA;AAE3B,MAAI,MAAM,SAAS,YAAY,iBAAiB;AAChD,SAAS,MAAK,QAAQ,WAAW,IAAI,QAAQ,WAAW,KAAK,MAAM,QAC5D,YAAW,IAAI,SAAS,KACxB,YAAW,IAAI,SAAS,KAAM;AAAA;;;ACtElC,2BAA2B,UAAU,WAAW;AACnD,MAAI,CAAC,YAAY,aAAa,WAAW,CAAE,aAAY,IAAI;AACvD,WAAO;AAAA;AAEX,SAAO,aAAa,WACd,CAAC,IAAI,WAAW,IAAI,aACpB,aAAa,WACT,CAAC,aACD,SAAS,YACL,CAAC,YAAY,QAAQ,YAAY,WAAW;AAAA;AAEvD,qBAAqB,IAAI;AAC5B,MAAI,QAAQ,GAAG;AACf,MAAI,WAAW,MAAM,YAAY,MAAM,YAAY,KAAK,kBAAkB,MAAM,UAAU,MAAM;AAChG,MAAI,iBAAiB,MAAM;AAC3B,MAAI,UAAU;AACV,QAAI,cAAe,MAAM,iBAAiB,GAAG,eAAgB,GAAG,iBAAiB;AACjF,QAAI,eAAe,gBAAgB,GAAG;AAClC,iBAAW,IAAI,UAAU,SAAU,QAAQ;AACvC,eAAO,SAAS;AAAA;AAEpB,wBAAkB;AAAA;AAAA;AAG1B,SAAO,CAAC,UAAU;AAAA;;;ACdtB,IAAI,mBAAmB,IAAI,kBAAU;AACrC,wBAAwB,OAAO;AAC3B,MAAI,SAAS,MAAM;AACnB,SAAO,CAAE,WAAU,QAAQ,WAAW,UAAU,CAAE,OAAM,YAAY;AAAA;AAExE,gCAAgC,cAAc;AAC1C,SAAO,OAAO,iBAAiB,YAAY,iBAAiB;AAAA;AAEhE,sBAAsB,OAAO;AACzB,MAAI,OAAO,MAAM;AACjB,SAAO,QAAQ,QAAQ,SAAS;AAAA;AAEpC,oBAAoB,KAAK,OAAO;AAC5B,MAAI,MAAM,eAAe,QAAQ,MAAM,gBAAgB,GAAG;AACtD,QAAI,sBAAsB,IAAI;AAC9B,QAAI,cAAc,MAAM,cAAc,MAAM;AAC5C,QAAI;AACJ,QAAI,cAAc;AAAA,SAEjB;AACD,QAAI;AAAA;AAAA;AAGZ,sBAAsB,KAAK,OAAO;AAC9B,MAAI,MAAM,iBAAiB,QAAQ,MAAM,kBAAkB,GAAG;AAC1D,QAAI,sBAAsB,IAAI;AAC9B,QAAI,cAAc,MAAM,gBAAgB,MAAM;AAC9C,QAAI;AACJ,QAAI,cAAc;AAAA,SAEjB;AACD,QAAI;AAAA;AAAA;AAGL,6BAA6B,KAAK,SAAS,IAAI;AAClD,MAAI,QAAQ,oBAAoB,QAAQ,OAAO,QAAQ,SAAS;AAChE,MAAI,aAAa,QAAQ;AACrB,QAAI,gBAAgB,IAAI,cAAc,OAAO,QAAQ,UAAU;AAC/D,QAAI,OAAO,cAAc,cAClB,iBACA,cAAc,cAAc;AAC/B,UAAI,SAAS,IAAI;AACjB,aAAO,cAAe,QAAQ,KAAK,GAAK,QAAQ,KAAK;AACrD,aAAO,WAAW,GAAG,GAAI,SAAQ,YAAY,KAAK;AAClD,aAAO,UAAW,QAAQ,UAAU,GAAK,QAAQ,UAAU;AAC3D,oBAAc,aAAa;AAAA;AAE/B,WAAO;AAAA;AAAA;AAGf,mBAAmB,KAAK,IAAI,OAAO,SAAS;AACxC,MAAI;AACJ,MAAI,YAAY,eAAe;AAC/B,MAAI,UAAU,aAAa;AAC3B,MAAI,gBAAgB,MAAM;AAC1B,MAAI,aAAa,gBAAgB;AACjC,MAAI,YAAY,CAAC,GAAG;AACpB,MAAK,EAAC,GAAG,UAAU,eAAe,WAAW;AACzC,OAAG;AAAA;AAEP,MAAI,OAAO,GAAG,QAAQ;AACtB,MAAI,YAAY,GAAG;AACnB,MAAI,CAAC,SAAS;AACV,QAAI,OAAO,MAAM;AACjB,QAAI,SAAS,MAAM;AACnB,QAAI,kBAAkB,WAAW,CAAC,CAAC,KAAK;AACxC,QAAI,oBAAoB,aAAa,CAAC,CAAC,OAAO;AAC9C,QAAI,iBAAiB,WAAW,CAAC,CAAC,KAAK;AACvC,QAAI,mBAAmB,aAAa,CAAC,CAAC,OAAO;AAC7C,QAAI,eAAe;AACnB,QAAI,iBAAiB;AACrB,QAAI,cAAc;AAClB,QAAI,gBAAgB;AACpB,QAAI,OAAO;AACX,QAAI,mBAAmB,mBAAmB;AACtC,aAAO,GAAG;AAAA;AAEd,QAAI,iBAAiB;AACjB,qBAAe,YACT,kBAAkB,KAAK,MAAM,QAC7B,GAAG;AACT,SAAG,uBAAuB;AAAA;AAE9B,QAAI,mBAAmB;AACnB,uBAAiB,YACX,kBAAkB,KAAK,QAAQ,QAC/B,GAAG;AACT,SAAG,yBAAyB;AAAA;AAEhC,QAAI,gBAAgB;AAChB,oBAAe,aAAa,CAAC,GAAG,sBAC1B,oBAAoB,KAAK,MAAM,MAC/B,GAAG;AACT,SAAG,sBAAsB;AAAA;AAE7B,QAAI,kBAAkB;AAClB,sBAAiB,aAAa,CAAC,GAAG,wBAC5B,oBAAoB,KAAK,QAAQ,MACjC,GAAG;AACT,SAAG,wBAAwB;AAAA;AAE/B,QAAI,iBAAiB;AACjB,UAAI,YAAY;AAAA,eAEX,gBAAgB;AACrB,UAAI,aAAa;AACb,YAAI,YAAY;AAAA,aAEf;AACD,kBAAU;AAAA;AAAA;AAGlB,QAAI,mBAAmB;AACnB,UAAI,cAAc;AAAA,eAEb,kBAAkB;AACvB,UAAI,eAAe;AACf,YAAI,cAAc;AAAA,aAEjB;AACD,oBAAY;AAAA;AAAA;AAAA;AAIxB,MAAI,QAAQ,GAAG;AACf,OAAK,SAAS,MAAM,IAAI,MAAM,IAAI,GAAG;AACrC,MAAI;AACJ,MAAI;AACJ,MAAI,IAAI,eAAe,MAAM,UAAU;AACnC,SAAK,YAAY,KAAK,WAAW,GAAG,IAAI,iBAAiB,GAAG;AAAA;AAEhE,MAAI,eAAe;AACnB,MAAI,aAAc,YAAY,mBAAoB;AAC9C,SAAK,OAAO,IAAI;AAChB,QAAI,YAAY;AACZ,WAAK,WAAW;AAAA,WAEf;AACD,WAAK,WAAW;AAChB,qBAAe;AAAA;AAEnB,SAAK;AACL,OAAG,UAAU,MAAM,GAAG,OAAO;AAC7B,SAAK;AACL,OAAG;AAAA;AAEP,MAAI,cAAc;AACd,SAAK,YAAY,KAAK,aAAa,gBAAgB;AAAA;AAEvD,MAAI,UAAU;AACV,QAAI,YAAY;AAChB,QAAI,iBAAiB;AAAA;AAEzB,MAAI,CAAC,SAAS;AACV,QAAI,MAAM,aAAa;AACnB,UAAI,WAAW;AACX,qBAAa,KAAK;AAAA;AAEtB,UAAI,SAAS;AACT,mBAAW,KAAK;AAAA;AAAA,WAGnB;AACD,UAAI,SAAS;AACT,mBAAW,KAAK;AAAA;AAEpB,UAAI,WAAW;AACX,qBAAa,KAAK;AAAA;AAAA;AAAA;AAI9B,MAAI,UAAU;AACV,QAAI,YAAY;AAAA;AAAA;AAGxB,oBAAoB,KAAK,IAAI,OAAO;AAChC,MAAI,QAAQ,GAAG,UAAU,oBAAoB,MAAM,OAAO,GAAG,SAAS,IAAI,GAAG;AAC7E,MAAI,CAAC,SAAS,CAAC,aAAa,QAAQ;AAChC;AAAA;AAEJ,MAAI,IAAI,MAAM,KAAK;AACnB,MAAI,IAAI,MAAM,KAAK;AACnB,MAAI,QAAQ,GAAG;AACf,MAAI,SAAS,GAAG;AAChB,MAAI,SAAS,MAAM,QAAQ,MAAM;AACjC,MAAI,SAAS,QAAQ,UAAU,MAAM;AACjC,YAAQ,SAAS;AAAA,aAEZ,UAAU,QAAQ,SAAS,MAAM;AACtC,aAAS,QAAQ;AAAA,aAEZ,SAAS,QAAQ,UAAU,MAAM;AACtC,YAAQ,MAAM;AACd,aAAS,MAAM;AAAA;AAEnB,MAAI,MAAM,UAAU,MAAM,SAAS;AAC/B,QAAI,KAAK,MAAM,MAAM;AACrB,QAAI,KAAK,MAAM,MAAM;AACrB,QAAI,UAAU,OAAO,IAAI,IAAI,MAAM,QAAQ,MAAM,SAAS,GAAG,GAAG,OAAO;AAAA,aAElE,MAAM,MAAM,MAAM,IAAI;AAC3B,QAAI,KAAK,MAAM;AACf,QAAI,KAAK,MAAM;AACf,QAAI,SAAS,QAAQ;AACrB,QAAI,UAAU,SAAS;AACvB,QAAI,UAAU,OAAO,IAAI,IAAI,QAAQ,SAAS,GAAG,GAAG,OAAO;AAAA,SAE1D;AACD,QAAI,UAAU,OAAO,GAAG,GAAG,OAAO;AAAA;AAAA;AAG1C,mBAAmB,KAAK,IAAI,OAAO;AAC/B,MAAI;AACJ,MAAI,OAAO,MAAM;AACjB,UAAQ,QAAS,SAAQ;AACzB,MAAI,MAAM;AACN,QAAI,OAAO,MAAM,QAAQ;AACzB,QAAI,YAAY,MAAM;AACtB,QAAI,eAAe,MAAM;AACzB,QAAI,WAAW;AACf,QAAI,iBAAiB;AACrB,QAAI,IAAI,eAAe,MAAM,UAAU;AACnC,WAAK,YAAY,KAAK,WAAW,GAAG,IAAI,iBAAiB,GAAG;AAAA;AAEhE,QAAI,UAAU;AACV,UAAI,YAAY;AAChB,UAAI,iBAAiB;AAAA;AAEzB,QAAI,MAAM,aAAa;AACnB,UAAI,eAAe,QAAQ;AACvB,YAAI,WAAW,MAAM,MAAM,GAAG,MAAM;AAAA;AAExC,UAAI,aAAa,QAAQ;AACrB,YAAI,SAAS,MAAM,MAAM,GAAG,MAAM;AAAA;AAAA,WAGrC;AACD,UAAI,aAAa,QAAQ;AACrB,YAAI,SAAS,MAAM,MAAM,GAAG,MAAM;AAAA;AAEtC,UAAI,eAAe,QAAQ;AACvB,YAAI,WAAW,MAAM,MAAM,GAAG,MAAM;AAAA;AAAA;AAG5C,QAAI,UAAU;AACV,UAAI,YAAY;AAAA;AAAA;AAAA;AAI5B,IAAI,sBAAsB,CAAC,cAAc,iBAAiB;AAC1D,IAAI,eAAe;AAAA,EACf,CAAC,WAAW;AAAA,EAAS,CAAC,YAAY;AAAA,EAAU,CAAC,cAAc;AAAA;AAE/D,yBAAyB,KAAK,OAAO,WAAW,aAAa,OAAO;AAChE,MAAI,eAAe;AACnB,MAAI,CAAC,aAAa;AACd,gBAAY,aAAa;AACzB,QAAI,UAAU,WAAW;AACrB,aAAO;AAAA;AAAA;AAGf,MAAI,eAAe,MAAM,YAAY,UAAU,SAAS;AACpD,mBAAe,KAAK;AACpB,mBAAe;AACf,QAAI,UAAU,KAAK,IAAI,KAAK,IAAI,MAAM,SAAS,IAAI;AACnD,QAAI,cAAc,MAAM,WAAW,qBAAqB,UAAU;AAAA;AAEtE,MAAI,eAAe,MAAM,UAAU,UAAU,OAAO;AAChD,QAAI,CAAC,cAAc;AACf,qBAAe,KAAK;AACpB,qBAAe;AAAA;AAEnB,QAAI,2BAA2B,MAAM,SAAS,qBAAqB;AAAA;AAEvE,WAAS,IAAI,GAAG,IAAI,oBAAoB,QAAQ,KAAK;AACjD,QAAI,WAAW,oBAAoB;AACnC,QAAI,eAAe,MAAM,cAAc,UAAU,WAAW;AACxD,UAAI,CAAC,cAAc;AACf,uBAAe,KAAK;AACpB,uBAAe;AAAA;AAEnB,UAAI,YAAY,IAAI,MAAO,OAAM,aAAa;AAAA;AAAA;AAGtD,MAAI,eAAe,MAAM,gBAAgB,UAAU,aAAa;AAC5D,QAAI,CAAC,cAAc;AACf,qBAAe,KAAK;AACpB,qBAAe;AAAA;AAEnB,QAAI,cAAc,MAAM,eAAe,qBAAqB;AAAA;AAEhE,SAAO;AAAA;AAEX,oCAAoC,KAAK,IAAI,QAAQ,aAAa,OAAO;AACrE,MAAI,QAAQ,SAAS,IAAI,MAAM;AAC/B,MAAI,YAAY,cACV,OACC,UAAU,SAAS,QAAQ,MAAM,YAAY;AACpD,MAAI,UAAU,WAAW;AACrB,WAAO;AAAA;AAEX,MAAI,eAAe,gBAAgB,KAAK,OAAO,WAAW,aAAa;AACvE,MAAI,eAAe,MAAM,SAAS,UAAU,MAAM;AAC9C,QAAI,CAAC,cAAc;AACf,qBAAe,KAAK;AACpB,qBAAe;AAAA;AAEnB,2BAAuB,MAAM,SAAU,KAAI,YAAY,MAAM;AAAA;AAEjE,MAAI,eAAe,MAAM,WAAW,UAAU,QAAQ;AAClD,QAAI,CAAC,cAAc;AACf,qBAAe,KAAK;AACpB,qBAAe;AAAA;AAEnB,2BAAuB,MAAM,WAAY,KAAI,cAAc,MAAM;AAAA;AAErE,MAAI,eAAe,MAAM,YAAY,UAAU,SAAS;AACpD,QAAI,CAAC,cAAc;AACf,qBAAe,KAAK;AACpB,qBAAe;AAAA;AAEnB,QAAI,cAAc,MAAM,WAAW,OAAO,IAAI,MAAM;AAAA;AAExD,MAAI,GAAG,aAAa;AAChB,QAAI,YAAY,MAAM;AACtB,QAAI,eAAe,YAAc,OAAM,iBAAiB,GAAG,eAAgB,GAAG,iBAAiB;AAC/F,QAAI,IAAI,cAAc,cAAc;AAChC,UAAI,CAAC,cAAc;AACf,uBAAe,KAAK;AACpB,uBAAe;AAAA;AAEnB,UAAI,YAAY;AAAA;AAAA;AAGxB,WAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC1C,QAAI,OAAO,aAAa;AACxB,QAAI,WAAW,KAAK;AACpB,QAAI,eAAe,MAAM,cAAc,UAAU,WAAW;AACxD,UAAI,CAAC,cAAc;AACf,uBAAe,KAAK;AACpB,uBAAe;AAAA;AAEnB,UAAI,YAAY,MAAM,aAAa,KAAK;AAAA;AAAA;AAGhD,SAAO;AAAA;AAEX,wBAAwB,KAAK,IAAI,QAAQ,aAAa,OAAO;AACzD,SAAO,gBAAgB,KAAK,SAAS,IAAI,MAAM,UAAU,UAAU,SAAS,QAAQ,MAAM,UAAU,aAAa;AAAA;AAErH,6BAA6B,KAAK,IAAI;AAClC,MAAI,IAAI,GAAG;AACX,MAAI,MAAM,IAAI,OAAO;AACrB,MAAI,GAAG;AACH,QAAI,aAAa,MAAM,EAAE,IAAI,MAAM,EAAE,IAAI,MAAM,EAAE,IAAI,MAAM,EAAE,IAAI,MAAM,EAAE,IAAI,MAAM,EAAE;AAAA,SAEpF;AACD,QAAI,aAAa,KAAK,GAAG,GAAG,KAAK,GAAG;AAAA;AAAA;AAG5C,0BAA0B,WAAW,KAAK,OAAO;AAC7C,MAAI,aAAa;AACjB,WAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACvC,QAAI,WAAW,UAAU;AACzB,iBAAa,cAAc,SAAS;AACpC,wBAAoB,KAAK;AACzB,QAAI;AACJ,aAAS,UAAU,KAAK,SAAS;AACjC,QAAI;AAAA;AAER,QAAM,aAAa;AAAA;AAEvB,4BAA4B,IAAI,IAAI;AAChC,MAAI,MAAM,IAAI;AACV,WAAO,GAAG,OAAO,GAAG,MACb,GAAG,OAAO,GAAG,MACb,GAAG,OAAO,GAAG,MACb,GAAG,OAAO,GAAG,MACb,GAAG,OAAO,GAAG,MACb,GAAG,OAAO,GAAG;AAAA,aAEf,CAAC,MAAM,CAAC,IAAI;AACjB,WAAO;AAAA;AAEX,SAAO;AAAA;AAEX,IAAI,iBAAiB;AACrB,IAAI,kBAAkB;AACtB,IAAI,iBAAiB;AACrB,IAAI,wBAAwB;AAC5B,sBAAsB,OAAO;AACzB,MAAI,UAAU,aAAa;AAC3B,MAAI,YAAY,eAAe;AAC/B,SAAO,CAAE,OAAM,YACR,CAAE,EAAC,UAAU,CAAC,cACb,WAAW,OAAO,MAAM,SAAS,YACjC,aAAa,OAAO,MAAM,WAAW,YACtC,MAAM,gBAAgB,KACtB,MAAM,gBAAgB,KACtB,MAAM,cAAc;AAAA;AAE/B,wBAAwB,KAAK,OAAO;AAChC,QAAM,aAAa,IAAI;AACvB,QAAM,eAAe,IAAI;AACzB,QAAM,YAAY;AAClB,QAAM,cAAc;AAAA;AAExB,kBAAkB,IAAI,SAAS;AAC3B,SAAO,UAAW,GAAG,gBAAgB,GAAG,QAAS,GAAG;AAAA;AAEjD,qBAAqB,KAAK,IAAI;AACjC,QAAM,KAAK,IAAI,EAAE,SAAS,OAAO,WAAW,GAAG,YAAY,KAAK;AAAA;AAE7D,eAAe,KAAK,IAAI,OAAO,QAAQ;AAC1C,MAAI,IAAI,GAAG;AACX,MAAI,CAAC,GAAG,gBAAgB,MAAM,WAAW,MAAM,YAAY,OAAO,QAAQ;AACtE,OAAG,WAAW,CAAC;AACf,OAAG,eAAe;AAClB;AAAA;AAEJ,MAAI,YAAY,GAAG;AACnB,MAAI,kBAAkB,MAAM;AAC5B,MAAI,oBAAoB;AACxB,MAAI,gBAAgB;AACpB,MAAI,CAAC,mBAAmB,kBAAkB,WAAW,kBAAkB;AACnE,QAAI,mBAAmB,gBAAgB,QAAQ;AAC3C,qBAAe,KAAK;AACpB,UAAI;AACJ,sBAAgB,oBAAoB;AACpC,YAAM,kBAAkB;AACxB,YAAM,aAAa;AACnB,YAAM,SAAS;AAAA;AAEnB,QAAI,aAAa,UAAU,QAAQ;AAC/B,qBAAe,KAAK;AACpB,UAAI;AACJ,uBAAiB,WAAW,KAAK;AACjC,0BAAoB;AAAA;AAExB,UAAM,kBAAkB;AAAA;AAE5B,MAAI,MAAM,YAAY;AAClB,OAAG,eAAe;AAClB;AAAA;AAEJ,KAAG,eAAe,GAAG;AACrB,KAAG;AACH,MAAI,SAAS,MAAM;AACnB,MAAI,CAAC,QAAQ;AACT,oBAAgB,oBAAoB;AAAA;AAExC,MAAI,eAAe,cAAc,gBAC1B,GAAG,aACH,aAAa,GAAG;AACvB,MAAI,qBAAqB,mBAAmB,GAAG,OAAO,YAAY;AAC9D,mBAAe,KAAK;AACpB,wBAAoB,KAAK;AAAA,aAEpB,CAAC,cAAc;AACpB,mBAAe,KAAK;AAAA;AAExB,MAAI,QAAQ,SAAS,IAAI,MAAM;AAC/B,MAAI,cAAc,cAAM;AACpB,QAAI,MAAM,iBAAiB,gBAAgB;AACvC,sBAAgB;AAChB,YAAM,eAAe;AAAA;AAEzB,+BAA2B,KAAK,IAAI,QAAQ,eAAe;AAC3D,QAAI,CAAC,gBAAiB,CAAC,MAAM,aAAa,CAAC,MAAM,aAAc;AAC3D,UAAI;AAAA;AAER,cAAU,KAAK,IAAI,OAAO;AAC1B,QAAI,cAAc;AACd,YAAM,YAAY,MAAM,QAAQ;AAChC,YAAM,cAAc,MAAM,UAAU;AAAA;AAAA,SAGvC;AACD,QAAI,cAAc,eAAO;AACrB,UAAI,MAAM,iBAAiB,gBAAgB;AACvC,wBAAgB;AAChB,cAAM,eAAe;AAAA;AAEzB,iCAA2B,KAAK,IAAI,QAAQ,eAAe;AAC3D,gBAAU,KAAK,IAAI;AAAA,eAEd,cAAc,eAAS;AAC5B,UAAI,MAAM,iBAAiB,iBAAiB;AACxC,wBAAgB;AAChB,cAAM,eAAe;AAAA;AAEzB,qBAAe,KAAK,IAAI,QAAQ,eAAe;AAC/C,iBAAW,KAAK,IAAI;AAAA,eAEf,GAAG,yBAAyB;AACjC,UAAI,MAAM,iBAAiB,uBAAuB;AAC9C,wBAAgB;AAChB,cAAM,eAAe;AAAA;AAEzB,uBAAiB,KAAK,IAAI;AAAA;AAAA;AAGlC,MAAI,gBAAgB,QAAQ;AACxB,mBAAe,KAAK;AAAA;AAExB,KAAG;AACH,KAAG,cAAc,GAAG;AACpB,QAAM,SAAS;AACf,KAAG,UAAU;AACb,KAAG,eAAe;AAAA;AAEtB,0BAA0B,KAAK,IAAI,OAAO;AACtC,MAAI,eAAe,GAAG;AACtB,MAAI,uBAAuB,GAAG;AAC9B,MAAI;AACJ,MAAI,aAAa;AAAA,IACb,iBAAiB;AAAA,IACjB,QAAQ;AAAA,IACR,YAAY;AAAA,IACZ,WAAW,MAAM;AAAA,IACjB,YAAY,MAAM;AAAA,IAClB,SAAS,MAAM;AAAA;AAEnB,MAAI;AACJ,MAAI;AACJ,OAAK,IAAI,GAAG,aAAa,MAAM,aAAa,QAAQ,IAAI,KAAK,KAAK;AAC9D,QAAI,cAAc,aAAa;AAC/B,gBAAY,eAAe,YAAY;AACvC,gBAAY;AACZ,UAAM,KAAK,aAAa,YAAY,MAAM,MAAM;AAChD,gBAAY;AACZ,gBAAY,cAAc,YAAY;AACtC,eAAW,SAAS;AAAA;AAExB,WAAS,MAAM,GAAG,QAAQ,qBAAqB,QAAQ,MAAM,OAAO,OAAO;AACvE,QAAI,cAAc,qBAAqB;AACvC,gBAAY,eAAe,YAAY;AACvC,gBAAY;AACZ,UAAM,KAAK,aAAa,YAAY,QAAQ,QAAQ;AACpD,gBAAY;AACZ,gBAAY,cAAc,YAAY;AACtC,eAAW,SAAS;AAAA;AAExB,KAAG;AACH,KAAG,WAAW;AACd,MAAI;AAAA;;;AC3iBR,IAAI;AACJ,wBAAyB,YAAI,mBACpB,QAAO,yBAAyB,OAAO,sBAAsB,KAAK,WAC/D,OAAO,2BAA2B,OAAO,wBAAwB,KAAK,WACvE,OAAO,4BACP,OAAO,gCAAiC,SAAU,MAAM;AAC/D,SAAO,WAAW,MAAM;AAAA;AAE5B,IAAO,gCAAQ;",
  "names": []
}
