import {
  computed,
  getCurrentInstance
} from "./chunk-M4WPYY6H.js";
import "./chunk-WKH64EM6.js";
import "./chunk-MS22ZBJX.js";

// node_modules/vuex-composition-helpers/dist/util.js
function runCB(cb, store, namespace, prop) {
  if (cb.length === 3) {
    return cb(store, namespace, prop);
  } else {
    return cb(store, namespace ? `${namespace}/${prop}` : prop);
  }
}
function useFromArray(store, namespace, props, cb) {
  return props.reduce((result, prop) => {
    result[prop] = runCB(cb, store, namespace, prop);
    return result;
  }, {});
}
function useFromObject(store, namespace, props, cb) {
  const obj = {};
  for (let key in props) {
    if (props.hasOwnProperty(key)) {
      obj[key] = runCB(cb, store, namespace, props[key]);
    }
  }
  return obj;
}
function computedGetter(store, prop) {
  return computed(() => store.getters[prop]);
}
function getMutation(store, mutation) {
  return function() {
    return store.commit.apply(store, [mutation, ...arguments]);
  };
}
function getAction(store, action) {
  return function() {
    return store.dispatch.apply(store, [action, ...arguments]);
  };
}
function useMapping(store, namespace, map, cb) {
  if (!map) {
    return {};
  }
  if (map instanceof Array) {
    return useFromArray(store, namespace, map, cb);
  }
  return useFromObject(store, namespace, map, cb);
}
function getStoreFromInstance() {
  const vm = getCurrentInstance();
  if (!vm) {
    throw new Error('You must use this function within the "setup()" method, or insert the store as first argument.');
  }
  const { $store } = "proxy" in vm ? vm.proxy : vm;
  return $store;
}

// node_modules/vuex-composition-helpers/dist/global.js
function computedState(store, prop) {
  return computed(() => store.state[prop]);
}
function computedNamespacedState(store, namespace, prop) {
  let module = namespace.split("/").reduce((module2, key) => module2[key], store.state);
  return computed(() => module[prop]);
}
function useStore() {
  return getStoreFromInstance();
}
function useState(storeOrNamespace, namespaceOrMap, map) {
  let realStore, realNamespace, realMap;
  if (arguments.length >= 3) {
    realStore = storeOrNamespace || getStoreFromInstance();
    realNamespace = namespaceOrMap || null;
    realMap = map || null;
  } else if (arguments.length === 2) {
    if (typeof storeOrNamespace === "string") {
      realStore = getStoreFromInstance();
      realNamespace = storeOrNamespace || null;
    } else {
      realStore = storeOrNamespace || getStoreFromInstance();
      realNamespace = null;
    }
    realMap = namespaceOrMap || null;
  } else {
    realStore = getStoreFromInstance();
    realNamespace = null;
    realMap = storeOrNamespace || null;
  }
  return useMapping(realStore, realNamespace, realMap, !realNamespace ? computedState : computedNamespacedState);
}
function useGetters(storeOrNamespace, namespaceOrMap, map) {
  let realStore, realNamespace, realMap;
  if (arguments.length >= 3) {
    realStore = storeOrNamespace || getStoreFromInstance();
    realNamespace = namespaceOrMap || null;
    realMap = map || null;
  } else if (arguments.length === 2) {
    if (typeof storeOrNamespace === "string") {
      realStore = getStoreFromInstance();
      realNamespace = storeOrNamespace || null;
    } else {
      realStore = storeOrNamespace || getStoreFromInstance();
      realNamespace = null;
    }
    realMap = namespaceOrMap || null;
  } else {
    realStore = getStoreFromInstance();
    realNamespace = null;
    realMap = storeOrNamespace || null;
  }
  return useMapping(realStore, realNamespace, realMap, computedGetter);
}
function useMutations(storeOrNamespace, namespaceOrMap, map) {
  let realStore, realNamespace, realMap;
  if (arguments.length >= 3) {
    realStore = storeOrNamespace || getStoreFromInstance();
    realNamespace = namespaceOrMap || null;
    realMap = map || null;
  } else if (arguments.length === 2) {
    if (typeof storeOrNamespace === "string") {
      realStore = getStoreFromInstance();
      realNamespace = storeOrNamespace || null;
    } else {
      realStore = storeOrNamespace || getStoreFromInstance();
      realNamespace = null;
    }
    realMap = namespaceOrMap || null;
  } else {
    realStore = getStoreFromInstance();
    realNamespace = null;
    realMap = storeOrNamespace || null;
  }
  return useMapping(realStore, realNamespace, realMap, getMutation);
}
function useActions(storeOrNamespace, namespaceOrMap, map) {
  let realStore, realNamespace, realMap;
  if (arguments.length >= 3) {
    realStore = storeOrNamespace || getStoreFromInstance();
    realNamespace = namespaceOrMap || null;
    realMap = map || null;
  } else if (arguments.length === 2) {
    if (typeof storeOrNamespace === "string") {
      realStore = getStoreFromInstance();
      realNamespace = storeOrNamespace || null;
    } else {
      realStore = storeOrNamespace || getStoreFromInstance();
      realNamespace = null;
    }
    realMap = namespaceOrMap || null;
  } else {
    realStore = getStoreFromInstance();
    realNamespace = null;
    realMap = storeOrNamespace || null;
  }
  return useMapping(realStore, realNamespace, realMap, getAction);
}

// node_modules/vuex-composition-helpers/dist/namespaced.js
var useNamespacedActions = useActions;
var useNamespacedGetters = useGetters;
var useNamespacedMutations = useMutations;
var useNamespacedState = useState;
function createNamespacedHelpers(storeOrNamespace, namespace) {
  let store = void 0;
  if (arguments.length === 1) {
    namespace = storeOrNamespace;
  } else {
    store = storeOrNamespace;
    if (!namespace) {
      throw new Error("Namespace is missing to provide namespaced helpers");
    }
  }
  return {
    useState: (map) => useState(store, namespace, map),
    useGetters: (map) => useGetters(store, namespace, map),
    useMutations: (map) => useMutations(store, namespace, map),
    useActions: (map) => useActions(store, namespace, map)
  };
}

// node_modules/vuex-composition-helpers/dist/wrapper.js
function wrapStore(store) {
  return {
    createNamespacedHelpers: createNamespacedHelpers.bind(null, store),
    useActions: useActions.bind(null, store),
    useGetters: useGetters.bind(null, store),
    useMutations: useMutations.bind(null, store),
    useState: useState.bind(null, store)
  };
}
export {
  createNamespacedHelpers,
  useActions,
  useGetters,
  useMutations,
  useNamespacedActions,
  useNamespacedGetters,
  useNamespacedMutations,
  useNamespacedState,
  useState,
  useStore,
  wrapStore
};
//# sourceMappingURL=vuex-composition-helpers.js.map
