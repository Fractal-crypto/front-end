import {
  Plugin,
  computed,
  getCurrentInstance
} from "./chunk-M4WPYY6H.js";
import {
  init_vue_runtime_esm,
  vue_runtime_esm_default
} from "./chunk-WKH64EM6.js";
import "./chunk-MS22ZBJX.js";

// node_modules/@vueblocks/vue-use-vuex/node_modules/vue-demi/lib/index.esm.js
init_vue_runtime_esm();
function install(_vue) {
  _vue = _vue || vue_runtime_esm_default;
  if (_vue && !_vue["__composition_api_installed__"])
    vue_runtime_esm_default.use(Plugin);
}
install(vue_runtime_esm_default);
var isVue3 = false;
var version = vue_runtime_esm_default.version;

// node_modules/@vueblocks/vue-use-vuex/lib/index.esm.js
var isObject = (val) => toString.call(val) === "[object Object]";
var isString = (str) => typeof str === "string";
var partial = (fn, ...partials) => (...args) => fn(...partials, ...args);
function isValidMap(map) {
  return Array.isArray(map) || isObject(map);
}
function normalizeMap(map) {
  if (!isValidMap(map)) {
    return [];
  }
  return Array.isArray(map) ? map.map((key) => ({ key, val: key })) : Object.keys(map).map((key) => ({ key, val: map[key] }));
}
function normalizeNamespace(fn) {
  return (namespace, map) => {
    if (!isString(namespace)) {
      map = namespace;
      namespace = "";
    } else if (namespace.charAt(namespace.length - 1) !== "/") {
      namespace += "/";
    }
    return fn(namespace, map);
  };
}
function getModuleByNamespace(store, helper, namespace) {
  const module = store._modulesNamespaceMap[namespace];
  if (!module) {
    console.error(`[vuex] module namespace not found in ${helper}(): ${namespace}`);
  }
  return module;
}
var useState = (store, namespace, states) => {
  const res = {};
  if (!isValidMap(states)) {
    console.error("[vuex] useState: mapper parameter must be either an Array or an Object");
  }
  normalizeMap(states).forEach(({ key, val }) => {
    res[key] = computed(function mappedState() {
      let state = store.state;
      let getters = store.getters;
      if (namespace) {
        const module = getModuleByNamespace(store, "useState", namespace);
        if (!module) {
          return;
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === "function" ? val(state, getters) : state[val];
    });
  });
  return res;
};
var useMutations = (store, namespace, mutations) => {
  const res = {};
  if (!isValidMap(mutations)) {
    console.error("[vuex] useMutations: mapper parameter must be either an Array or an Object");
  }
  normalizeMap(mutations).forEach(({ key, val }) => {
    res[key] = function mappedMutation(...args) {
      let commit = store.commit;
      if (namespace) {
        const module = getModuleByNamespace(store, "useMutations", namespace);
        if (!module) {
          return;
        }
        commit = module.context.commit;
      }
      return typeof val === "function" ? val.apply(this, [commit].concat(args)) : commit.apply(store, [val].concat(args));
    };
  });
  return res;
};
var useGetters = (store, namespace, getters) => {
  const res = {};
  if (!isValidMap(getters)) {
    console.error("[vuex] useGetters: mapper parameter must be either an Array or an Object");
  }
  normalizeMap(getters).forEach(({ key, val }) => {
    val = namespace + val;
    res[key] = computed(function mappedGetter() {
      if (namespace && !getModuleByNamespace(store, "useGetters", namespace)) {
        return;
      }
      if (!(val in store.getters)) {
        console.error(`[vuex] unknown getter: ${val}`);
        return;
      }
      return store.getters[val];
    });
  });
  return res;
};
var useActions = (store, namespace, actions) => {
  const res = {};
  if (!isValidMap(actions)) {
    console.error("[vuex] useActions: mapper parameter must be either an Array or an Object");
  }
  normalizeMap(actions).forEach(({ key, val }) => {
    res[key] = function mappedAction(...args) {
      let dispatch = store.dispatch;
      if (namespace) {
        const module = getModuleByNamespace(store, "useActions", namespace);
        if (!module) {
          return;
        }
        dispatch = module.context.dispatch;
      }
      return typeof val === "function" ? val.apply(this, [dispatch].concat(args)) : dispatch.apply(store, [val].concat(args));
    };
  });
  return res;
};
var createNamespacedHelpers = (store, namespace) => {
  return {
    useState: partial(normalizeNamespace(partial(useState, store)), namespace),
    useGetters: partial(normalizeNamespace(partial(useGetters, store)), namespace),
    useMutations: partial(normalizeNamespace(partial(useMutations, store)), namespace),
    useActions: partial(normalizeNamespace(partial(useActions, store)), namespace)
  };
};
var useStore = () => {
  const instance = getCurrentInstance();
  if (!instance) {
    console.error('You must use this function within the "setup()" method');
  }
  return isVue3 ? instance.ctx.$store : instance.proxy.$store;
};
function useVuex(namespace, store) {
  if (!store)
    store = useStore();
  let helpers = {
    useState: normalizeNamespace(partial(useState, store)),
    useGetters: normalizeNamespace(partial(useGetters, store)),
    useMutations: normalizeNamespace(partial(useMutations, store)),
    useActions: normalizeNamespace(partial(useActions, store))
  };
  if (arguments.length >= 1 && isString(namespace)) {
    helpers = partial(createNamespacedHelpers, store)(namespace);
  }
  return helpers;
}
export {
  createNamespacedHelpers,
  useActions,
  useGetters,
  useMutations,
  useState,
  useStore,
  useVuex
};
/*!
 * @vueblocks/vue-use-vuex v0.2.10
 * (c) 2021 xiaoluoboding
 * @license MIT
 */
//# sourceMappingURL=@vueblocks_vue-use-vuex.js.map
