import {
  createDecorator,
  mixins,
  vue_class_component_esm_default
} from "./chunk-MWZ3WLE5.js";
import {
  init_vue_runtime_esm,
  vue_runtime_esm_default
} from "./chunk-WKH64EM6.js";
import "./chunk-MS22ZBJX.js";

// node_modules/vue-property-decorator/lib/index.js
init_vue_runtime_esm();

// node_modules/vue-property-decorator/lib/decorators/Emit.js
var __spreadArrays = function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = function(str) {
  return str.replace(hyphenateRE, "-$1").toLowerCase();
};
function Emit(event) {
  return function(_target, propertyKey, descriptor) {
    var key = hyphenate(propertyKey);
    var original = descriptor.value;
    descriptor.value = function emitter() {
      var _this = this;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var emit = function(returnValue2) {
        var emitName = event || key;
        if (returnValue2 === void 0) {
          if (args.length === 0) {
            _this.$emit(emitName);
          } else if (args.length === 1) {
            _this.$emit(emitName, args[0]);
          } else {
            _this.$emit.apply(_this, __spreadArrays([emitName], args));
          }
        } else {
          args.unshift(returnValue2);
          _this.$emit.apply(_this, __spreadArrays([emitName], args));
        }
      };
      var returnValue = original.apply(this, args);
      if (isPromise(returnValue)) {
        returnValue.then(emit);
      } else {
        emit(returnValue);
      }
      return returnValue;
    };
  };
}
function isPromise(obj) {
  return obj instanceof Promise || obj && typeof obj.then === "function";
}

// node_modules/vue-property-decorator/lib/decorators/Inject.js
function Inject(options) {
  return createDecorator(function(componentOptions, key) {
    if (typeof componentOptions.inject === "undefined") {
      componentOptions.inject = {};
    }
    if (!Array.isArray(componentOptions.inject)) {
      componentOptions.inject[key] = options || key;
    }
  });
}

// node_modules/vue-property-decorator/lib/helpers/provideInject.js
function needToProduceProvide(original) {
  return typeof original !== "function" || !original.managed && !original.managedReactive;
}
function produceProvide(original) {
  var provide = function() {
    var _this = this;
    var rv = typeof original === "function" ? original.call(this) : original;
    rv = Object.create(rv || null);
    rv[reactiveInjectKey] = Object.create(this[reactiveInjectKey] || {});
    for (var i in provide.managed) {
      rv[provide.managed[i]] = this[i];
    }
    var _loop_1 = function(i2) {
      rv[provide.managedReactive[i2]] = this_1[i2];
      Object.defineProperty(rv[reactiveInjectKey], provide.managedReactive[i2], {
        enumerable: true,
        configurable: true,
        get: function() {
          return _this[i2];
        }
      });
    };
    var this_1 = this;
    for (var i in provide.managedReactive) {
      _loop_1(i);
    }
    return rv;
  };
  provide.managed = {};
  provide.managedReactive = {};
  return provide;
}
var reactiveInjectKey = "__reactiveInject__";
function inheritInjected(componentOptions) {
  if (!Array.isArray(componentOptions.inject)) {
    componentOptions.inject = componentOptions.inject || {};
    componentOptions.inject[reactiveInjectKey] = {
      from: reactiveInjectKey,
      default: {}
    };
  }
}

// node_modules/vue-property-decorator/lib/decorators/InjectReactive.js
function InjectReactive(options) {
  return createDecorator(function(componentOptions, key) {
    if (typeof componentOptions.inject === "undefined") {
      componentOptions.inject = {};
    }
    if (!Array.isArray(componentOptions.inject)) {
      var fromKey_1 = !!options ? options.from || options : key;
      var defaultVal_1 = !!options && options.default || void 0;
      if (!componentOptions.computed)
        componentOptions.computed = {};
      componentOptions.computed[key] = function() {
        var obj = this[reactiveInjectKey];
        return obj ? obj[fromKey_1] : defaultVal_1;
      };
      componentOptions.inject[reactiveInjectKey] = reactiveInjectKey;
    }
  });
}

// node_modules/vue-property-decorator/lib/helpers/metadata.js
var reflectMetadataIsSupported = typeof Reflect !== "undefined" && typeof Reflect.getMetadata !== "undefined";
function applyMetadata(options, target, key) {
  if (reflectMetadataIsSupported) {
    if (!Array.isArray(options) && typeof options !== "function" && !options.hasOwnProperty("type") && typeof options.type === "undefined") {
      var type = Reflect.getMetadata("design:type", target, key);
      if (type !== Object) {
        options.type = type;
      }
    }
  }
}

// node_modules/vue-property-decorator/lib/decorators/Model.js
function Model(event, options) {
  if (options === void 0) {
    options = {};
  }
  return function(target, key) {
    applyMetadata(options, target, key);
    createDecorator(function(componentOptions, k) {
      ;
      (componentOptions.props || (componentOptions.props = {}))[k] = options;
      componentOptions.model = { prop: k, event: event || k };
    })(target, key);
  };
}

// node_modules/vue-property-decorator/lib/decorators/ModelSync.js
function ModelSync(propName, event, options) {
  if (options === void 0) {
    options = {};
  }
  return function(target, key) {
    applyMetadata(options, target, key);
    createDecorator(function(componentOptions, k) {
      ;
      (componentOptions.props || (componentOptions.props = {}))[propName] = options;
      componentOptions.model = { prop: propName, event: event || k };
      (componentOptions.computed || (componentOptions.computed = {}))[k] = {
        get: function() {
          return this[propName];
        },
        set: function(value) {
          this.$emit(event, value);
        }
      };
    })(target, key);
  };
}

// node_modules/vue-property-decorator/lib/decorators/Prop.js
function Prop(options) {
  if (options === void 0) {
    options = {};
  }
  return function(target, key) {
    applyMetadata(options, target, key);
    createDecorator(function(componentOptions, k) {
      ;
      (componentOptions.props || (componentOptions.props = {}))[k] = options;
    })(target, key);
  };
}

// node_modules/vue-property-decorator/lib/decorators/PropSync.js
function PropSync(propName, options) {
  if (options === void 0) {
    options = {};
  }
  return function(target, key) {
    applyMetadata(options, target, key);
    createDecorator(function(componentOptions, k) {
      ;
      (componentOptions.props || (componentOptions.props = {}))[propName] = options;
      (componentOptions.computed || (componentOptions.computed = {}))[k] = {
        get: function() {
          return this[propName];
        },
        set: function(value) {
          this.$emit("update:" + propName, value);
        }
      };
    })(target, key);
  };
}

// node_modules/vue-property-decorator/lib/decorators/Provide.js
function Provide(key) {
  return createDecorator(function(componentOptions, k) {
    var provide = componentOptions.provide;
    inheritInjected(componentOptions);
    if (needToProduceProvide(provide)) {
      provide = componentOptions.provide = produceProvide(provide);
    }
    provide.managed[k] = key || k;
  });
}

// node_modules/vue-property-decorator/lib/decorators/ProvideReactive.js
function ProvideReactive(key) {
  return createDecorator(function(componentOptions, k) {
    var provide = componentOptions.provide;
    inheritInjected(componentOptions);
    if (needToProduceProvide(provide)) {
      provide = componentOptions.provide = produceProvide(provide);
    }
    provide.managedReactive[k] = key || k;
  });
}

// node_modules/vue-property-decorator/lib/decorators/Ref.js
function Ref(refKey) {
  return createDecorator(function(options, key) {
    options.computed = options.computed || {};
    options.computed[key] = {
      cache: false,
      get: function() {
        return this.$refs[refKey || key];
      }
    };
  });
}

// node_modules/vue-property-decorator/lib/decorators/VModel.js
function VModel(options) {
  if (options === void 0) {
    options = {};
  }
  var valueKey = "value";
  return createDecorator(function(componentOptions, key) {
    ;
    (componentOptions.props || (componentOptions.props = {}))[valueKey] = options;
    (componentOptions.computed || (componentOptions.computed = {}))[key] = {
      get: function() {
        return this[valueKey];
      },
      set: function(value) {
        this.$emit("input", value);
      }
    };
  });
}

// node_modules/vue-property-decorator/lib/decorators/Watch.js
function Watch(path, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.deep, deep = _a === void 0 ? false : _a, _b = options.immediate, immediate = _b === void 0 ? false : _b;
  return createDecorator(function(componentOptions, handler) {
    if (typeof componentOptions.watch !== "object") {
      componentOptions.watch = /* @__PURE__ */ Object.create(null);
    }
    var watch = componentOptions.watch;
    if (typeof watch[path] === "object" && !Array.isArray(watch[path])) {
      watch[path] = [watch[path]];
    } else if (typeof watch[path] === "undefined") {
      watch[path] = [];
    }
    watch[path].push({ handler, deep, immediate });
  });
}
export {
  vue_class_component_esm_default as Component,
  Emit,
  Inject,
  InjectReactive,
  mixins as Mixins,
  Model,
  ModelSync,
  Prop,
  PropSync,
  Provide,
  ProvideReactive,
  Ref,
  VModel,
  vue_runtime_esm_default as Vue,
  Watch
};
//# sourceMappingURL=vue-property-decorator.js.map
