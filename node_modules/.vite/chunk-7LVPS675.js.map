{
  "version": 3,
  "sources": ["../echarts/lib/label/labelGuideHelper.js"],
  "sourcesContent": ["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { Point, Path, Polyline } from '../util/graphic.js';\nimport PathProxy from 'zrender/lib/core/PathProxy.js';\nimport { normalizeRadian } from 'zrender/lib/contain/util.js';\nimport { cubicProjectPoint, quadraticProjectPoint } from 'zrender/lib/core/curve.js';\nimport { defaults, retrieve2 } from 'zrender/lib/core/util.js';\nimport { invert } from 'zrender/lib/core/matrix.js';\nimport * as vector from 'zrender/lib/core/vector.js';\nimport { DISPLAY_STATES, SPECIAL_STATES } from '../util/states.js';\nvar PI2 = Math.PI * 2;\nvar CMD = PathProxy.CMD;\nvar DEFAULT_SEARCH_SPACE = ['top', 'right', 'bottom', 'left'];\n\nfunction getCandidateAnchor(pos, distance, rect, outPt, outDir) {\n  var width = rect.width;\n  var height = rect.height;\n\n  switch (pos) {\n    case 'top':\n      outPt.set(rect.x + width / 2, rect.y - distance);\n      outDir.set(0, -1);\n      break;\n\n    case 'bottom':\n      outPt.set(rect.x + width / 2, rect.y + height + distance);\n      outDir.set(0, 1);\n      break;\n\n    case 'left':\n      outPt.set(rect.x - distance, rect.y + height / 2);\n      outDir.set(-1, 0);\n      break;\n\n    case 'right':\n      outPt.set(rect.x + width + distance, rect.y + height / 2);\n      outDir.set(1, 0);\n      break;\n  }\n}\n\nfunction projectPointToArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y, out) {\n  x -= cx;\n  y -= cy;\n  var d = Math.sqrt(x * x + y * y);\n  x /= d;\n  y /= d; // Intersect point.\n\n  var ox = x * r + cx;\n  var oy = y * r + cy;\n\n  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n    // Is a circle\n    out[0] = ox;\n    out[1] = oy;\n    return d - r;\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var angle = Math.atan2(y, x);\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n    // Project point is on the arc.\n    out[0] = ox;\n    out[1] = oy;\n    return d - r;\n  }\n\n  var x1 = r * Math.cos(startAngle) + cx;\n  var y1 = r * Math.sin(startAngle) + cy;\n  var x2 = r * Math.cos(endAngle) + cx;\n  var y2 = r * Math.sin(endAngle) + cy;\n  var d1 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);\n  var d2 = (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);\n\n  if (d1 < d2) {\n    out[0] = x1;\n    out[1] = y1;\n    return Math.sqrt(d1);\n  } else {\n    out[0] = x2;\n    out[1] = y2;\n    return Math.sqrt(d2);\n  }\n}\n\nfunction projectPointToLine(x1, y1, x2, y2, x, y, out, limitToEnds) {\n  var dx = x - x1;\n  var dy = y - y1;\n  var dx1 = x2 - x1;\n  var dy1 = y2 - y1;\n  var lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n  dx1 /= lineLen;\n  dy1 /= lineLen; // dot product\n\n  var projectedLen = dx * dx1 + dy * dy1;\n  var t = projectedLen / lineLen;\n\n  if (limitToEnds) {\n    t = Math.min(Math.max(t, 0), 1);\n  }\n\n  t *= lineLen;\n  var ox = out[0] = x1 + t * dx1;\n  var oy = out[1] = y1 + t * dy1;\n  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));\n}\n\nfunction projectPointToRect(x1, y1, width, height, x, y, out) {\n  if (width < 0) {\n    x1 = x1 + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y1 = y1 + height;\n    height = -height;\n  }\n\n  var x2 = x1 + width;\n  var y2 = y1 + height;\n  var ox = out[0] = Math.min(Math.max(x, x1), x2);\n  var oy = out[1] = Math.min(Math.max(y, y1), y2);\n  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));\n}\n\nvar tmpPt = [];\n\nfunction nearestPointOnRect(pt, rect, out) {\n  var dist = projectPointToRect(rect.x, rect.y, rect.width, rect.height, pt.x, pt.y, tmpPt);\n  out.set(tmpPt[0], tmpPt[1]);\n  return dist;\n}\n/**\n * Calculate min distance corresponding point.\n * This method won't evaluate if point is in the path.\n */\n\n\nfunction nearestPointOnPath(pt, path, out) {\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n  var x1;\n  var y1;\n  var minDist = Infinity;\n  var data = path.data;\n  var x = pt.x;\n  var y = pt.y;\n\n  for (var i = 0; i < data.length;) {\n    var cmd = data[i++];\n\n    if (i === 1) {\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n    }\n\n    var d = minDist;\n\n    switch (cmd) {\n      case CMD.M:\n        // moveTo \u547D\u4EE4\u91CD\u65B0\u521B\u5EFA\u4E00\u4E2A\u65B0\u7684 subpath, \u5E76\u4E14\u66F4\u65B0\u65B0\u7684\u8D77\u70B9\n        // \u5728 closePath \u7684\u65F6\u5019\u4F7F\u7528\n        x0 = data[i++];\n        y0 = data[i++];\n        xi = x0;\n        yi = y0;\n        break;\n\n      case CMD.L:\n        d = projectPointToLine(xi, yi, data[i], data[i + 1], x, y, tmpPt, true);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.C:\n        d = cubicProjectPoint(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.Q:\n        d = quadraticProjectPoint(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.A:\n        // TODO Arc \u5224\u65AD\u7684\u5F00\u9500\u6BD4\u8F83\u5927\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++]; // TODO Arc \u65CB\u8F6C\n\n        i += 1;\n        var anticlockwise = !!(1 - data[i++]);\n        x1 = Math.cos(theta) * rx + cx;\n        y1 = Math.sin(theta) * ry + cy; // \u4E0D\u662F\u76F4\u63A5\u4F7F\u7528 arc \u547D\u4EE4\n\n        if (i <= 1) {\n          // \u7B2C\u4E00\u4E2A\u547D\u4EE4\u8D77\u70B9\u8FD8\u672A\u5B9A\u4E49\n          x0 = x1;\n          y0 = y1;\n        } // zr \u4F7F\u7528scale\u6765\u6A21\u62DF\u692D\u5706, \u8FD9\u91CC\u4E5F\u5BF9x\u505A\u4E00\u5B9A\u7684\u7F29\u653E\n\n\n        var _x = (x - cx) * ry / rx + cx;\n\n        d = projectPointToArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y, tmpPt);\n        xi = Math.cos(theta + dTheta) * rx + cx;\n        yi = Math.sin(theta + dTheta) * ry + cy;\n        break;\n\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        var width = data[i++];\n        var height = data[i++];\n        d = projectPointToRect(x0, y0, width, height, x, y, tmpPt);\n        break;\n\n      case CMD.Z:\n        d = projectPointToLine(xi, yi, x0, y0, x, y, tmpPt, true);\n        xi = x0;\n        yi = y0;\n        break;\n    }\n\n    if (d < minDist) {\n      minDist = d;\n      out.set(tmpPt[0], tmpPt[1]);\n    }\n  }\n\n  return minDist;\n} // Temporal varible for intermediate usage.\n\n\nvar pt0 = new Point();\nvar pt1 = new Point();\nvar pt2 = new Point();\nvar dir = new Point();\nvar dir2 = new Point();\n/**\n * Calculate a proper guide line based on the label position and graphic element definition\n * @param label\n * @param labelRect\n * @param target\n * @param targetRect\n */\n\nexport function updateLabelLinePoints(target, labelLineModel) {\n  if (!target) {\n    return;\n  }\n\n  var labelLine = target.getTextGuideLine();\n  var label = target.getTextContent(); // Needs to create text guide in each charts.\n\n  if (!(label && labelLine)) {\n    return;\n  }\n\n  var labelGuideConfig = target.textGuideLineConfig || {};\n  var points = [[0, 0], [0, 0], [0, 0]];\n  var searchSpace = labelGuideConfig.candidates || DEFAULT_SEARCH_SPACE;\n  var labelRect = label.getBoundingRect().clone();\n  labelRect.applyTransform(label.getComputedTransform());\n  var minDist = Infinity;\n  var anchorPoint = labelGuideConfig.anchor;\n  var targetTransform = target.getComputedTransform();\n  var targetInversedTransform = targetTransform && invert([], targetTransform);\n  var len = labelLineModel.get('length2') || 0;\n\n  if (anchorPoint) {\n    pt2.copy(anchorPoint);\n  }\n\n  for (var i = 0; i < searchSpace.length; i++) {\n    var candidate = searchSpace[i];\n    getCandidateAnchor(candidate, 0, labelRect, pt0, dir);\n    Point.scaleAndAdd(pt1, pt0, dir, len); // Transform to target coord space.\n\n    pt1.transform(targetInversedTransform); // Note: getBoundingRect will ensure the `path` being created.\n\n    var boundingRect = target.getBoundingRect();\n    var dist = anchorPoint ? anchorPoint.distance(pt1) : target instanceof Path ? nearestPointOnPath(pt1, target.path, pt2) : nearestPointOnRect(pt1, boundingRect, pt2); // TODO pt2 is in the path\n\n    if (dist < minDist) {\n      minDist = dist; // Transform back to global space.\n\n      pt1.transform(targetTransform);\n      pt2.transform(targetTransform);\n      pt2.toArray(points[0]);\n      pt1.toArray(points[1]);\n      pt0.toArray(points[2]);\n    }\n  }\n\n  limitTurnAngle(points, labelLineModel.get('minTurnAngle'));\n  labelLine.setShape({\n    points: points\n  });\n} // Temporal variable for the limitTurnAngle function\n\nvar tmpArr = [];\nvar tmpProjPoint = new Point();\n/**\n * Reduce the line segment attached to the label to limit the turn angle between two segments.\n * @param linePoints\n * @param minTurnAngle Radian of minimum turn angle. 0 - 180\n */\n\nexport function limitTurnAngle(linePoints, minTurnAngle) {\n  if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {\n    return;\n  }\n\n  minTurnAngle = minTurnAngle / 180 * Math.PI; // The line points can be\n  //      /pt1----pt2 (label)\n  //     /\n  // pt0/\n\n  pt0.fromArray(linePoints[0]);\n  pt1.fromArray(linePoints[1]);\n  pt2.fromArray(linePoints[2]);\n  Point.sub(dir, pt0, pt1);\n  Point.sub(dir2, pt2, pt1);\n  var len1 = dir.len();\n  var len2 = dir2.len();\n\n  if (len1 < 1e-3 || len2 < 1e-3) {\n    return;\n  }\n\n  dir.scale(1 / len1);\n  dir2.scale(1 / len2);\n  var angleCos = dir.dot(dir2);\n  var minTurnAngleCos = Math.cos(minTurnAngle);\n\n  if (minTurnAngleCos < angleCos) {\n    // Smaller than minTurnAngle\n    // Calculate project point of pt0 on pt1-pt2\n    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);\n    tmpProjPoint.fromArray(tmpArr); // Calculate new projected length with limited minTurnAngle and get the new connect point\n\n    tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI - minTurnAngle)); // Limit the new calculated connect point between pt1 and pt2.\n\n    var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);\n\n    if (isNaN(t)) {\n      return;\n    }\n\n    if (t < 0) {\n      Point.copy(tmpProjPoint, pt1);\n    } else if (t > 1) {\n      Point.copy(tmpProjPoint, pt2);\n    }\n\n    tmpProjPoint.toArray(linePoints[1]);\n  }\n}\n/**\n * Limit the angle of line and the surface\n * @param maxSurfaceAngle Radian of minimum turn angle. 0 - 180. 0 is same direction to normal. 180 is opposite\n */\n\nexport function limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {\n  if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {\n    return;\n  }\n\n  maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;\n  pt0.fromArray(linePoints[0]);\n  pt1.fromArray(linePoints[1]);\n  pt2.fromArray(linePoints[2]);\n  Point.sub(dir, pt1, pt0);\n  Point.sub(dir2, pt2, pt1);\n  var len1 = dir.len();\n  var len2 = dir2.len();\n\n  if (len1 < 1e-3 || len2 < 1e-3) {\n    return;\n  }\n\n  dir.scale(1 / len1);\n  dir2.scale(1 / len2);\n  var angleCos = dir.dot(surfaceNormal);\n  var maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);\n\n  if (angleCos < maxSurfaceAngleCos) {\n    // Calculate project point of pt0 on pt1-pt2\n    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);\n    tmpProjPoint.fromArray(tmpArr);\n    var HALF_PI = Math.PI / 2;\n    var angle2 = Math.acos(dir2.dot(surfaceNormal));\n    var newAngle = HALF_PI + angle2 - maxSurfaceAngle;\n\n    if (newAngle >= HALF_PI) {\n      // parallel\n      Point.copy(tmpProjPoint, pt2);\n    } else {\n      // Calculate new projected length with limited minTurnAngle and get the new connect point\n      tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI / 2 - newAngle)); // Limit the new calculated connect point between pt1 and pt2.\n\n      var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);\n\n      if (isNaN(t)) {\n        return;\n      }\n\n      if (t < 0) {\n        Point.copy(tmpProjPoint, pt1);\n      } else if (t > 1) {\n        Point.copy(tmpProjPoint, pt2);\n      }\n    }\n\n    tmpProjPoint.toArray(linePoints[1]);\n  }\n}\n\nfunction setLabelLineState(labelLine, ignore, stateName, stateModel) {\n  var isNormal = stateName === 'normal';\n  var stateObj = isNormal ? labelLine : labelLine.ensureState(stateName); // Make sure display.\n\n  stateObj.ignore = ignore; // Set smooth\n\n  var smooth = stateModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.3;\n  }\n\n  stateObj.shape = stateObj.shape || {};\n\n  if (smooth > 0) {\n    stateObj.shape.smooth = smooth;\n  }\n\n  var styleObj = stateModel.getModel('lineStyle').getLineStyle();\n  isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;\n}\n\nfunction buildLabelLinePath(path, shape) {\n  var smooth = shape.smooth;\n  var points = shape.points;\n\n  if (!points) {\n    return;\n  }\n\n  path.moveTo(points[0][0], points[0][1]);\n\n  if (smooth > 0 && points.length >= 3) {\n    var len1 = vector.dist(points[0], points[1]);\n    var len2 = vector.dist(points[1], points[2]);\n\n    if (!len1 || !len2) {\n      path.lineTo(points[1][0], points[1][1]);\n      path.lineTo(points[2][0], points[2][1]);\n      return;\n    }\n\n    var moveLen = Math.min(len1, len2) * smooth;\n    var midPoint0 = vector.lerp([], points[1], points[0], moveLen / len1);\n    var midPoint2 = vector.lerp([], points[1], points[2], moveLen / len2);\n    var midPoint1 = vector.lerp([], midPoint0, midPoint2, 0.5);\n    path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);\n    path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points[2][0], points[2][1]);\n  } else {\n    for (var i = 1; i < points.length; i++) {\n      path.lineTo(points[i][0], points[i][1]);\n    }\n  }\n}\n/**\n * Create a label line if necessary and set it's style.\n */\n\n\nexport function setLabelLineStyle(targetEl, statesModels, defaultStyle) {\n  var labelLine = targetEl.getTextGuideLine();\n  var label = targetEl.getTextContent();\n\n  if (!label) {\n    // Not show label line if there is no label.\n    if (labelLine) {\n      targetEl.removeTextGuideLine();\n    }\n\n    return;\n  }\n\n  var normalModel = statesModels.normal;\n  var showNormal = normalModel.get('show');\n  var labelIgnoreNormal = label.ignore;\n\n  for (var i = 0; i < DISPLAY_STATES.length; i++) {\n    var stateName = DISPLAY_STATES[i];\n    var stateModel = statesModels[stateName];\n    var isNormal = stateName === 'normal';\n\n    if (stateModel) {\n      var stateShow = stateModel.get('show');\n      var isLabelIgnored = isNormal ? labelIgnoreNormal : retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);\n\n      if (isLabelIgnored // Not show when label is not shown in this state.\n      || !retrieve2(stateShow, showNormal) // Use normal state by default if not set.\n      ) {\n          var stateObj = isNormal ? labelLine : labelLine && labelLine.states.normal;\n\n          if (stateObj) {\n            stateObj.ignore = true;\n          }\n\n          continue;\n        } // Create labelLine if not exists\n\n\n      if (!labelLine) {\n        labelLine = new Polyline();\n        targetEl.setTextGuideLine(labelLine); // Reset state of normal because it's new created.\n        // NOTE: NORMAL should always been the first!\n\n        if (!isNormal && (labelIgnoreNormal || !showNormal)) {\n          setLabelLineState(labelLine, true, 'normal', statesModels.normal);\n        } // Use same state proxy.\n\n\n        if (targetEl.stateProxy) {\n          labelLine.stateProxy = targetEl.stateProxy;\n        }\n      }\n\n      setLabelLineState(labelLine, false, stateName, stateModel);\n    }\n  }\n\n  if (labelLine) {\n    defaults(labelLine.style, defaultStyle); // Not fill.\n\n    labelLine.style.fill = null;\n    var showAbove = normalModel.get('showAbove');\n    var labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};\n    labelLineConfig.showAbove = showAbove || false; // Custom the buildPath.\n\n    labelLine.buildPath = buildLabelLinePath;\n  }\n}\nexport function getLabelLineStatesModels(itemModel, labelLineName) {\n  labelLineName = labelLineName || 'labelLine';\n  var statesModels = {\n    normal: itemModel.getModel(labelLineName)\n  };\n\n  for (var i = 0; i < SPECIAL_STATES.length; i++) {\n    var stateName = SPECIAL_STATES[i];\n    statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);\n  }\n\n  return statesModels;\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAmDA,IAAI,MAAM,KAAK,KAAK;AACpB,IAAI,MAAM,kBAAU;AACpB,IAAI,uBAAuB,CAAC,OAAO,SAAS,UAAU;AAEtD,4BAA4B,KAAK,UAAU,MAAM,OAAO,QAAQ;AAC9D,MAAI,QAAQ,KAAK;AACjB,MAAI,SAAS,KAAK;AAElB,UAAQ;AAAA,SACD;AACH,YAAM,IAAI,KAAK,IAAI,QAAQ,GAAG,KAAK,IAAI;AACvC,aAAO,IAAI,GAAG;AACd;AAAA,SAEG;AACH,YAAM,IAAI,KAAK,IAAI,QAAQ,GAAG,KAAK,IAAI,SAAS;AAChD,aAAO,IAAI,GAAG;AACd;AAAA,SAEG;AACH,YAAM,IAAI,KAAK,IAAI,UAAU,KAAK,IAAI,SAAS;AAC/C,aAAO,IAAI,IAAI;AACf;AAAA,SAEG;AACH,YAAM,IAAI,KAAK,IAAI,QAAQ,UAAU,KAAK,IAAI,SAAS;AACvD,aAAO,IAAI,GAAG;AACd;AAAA;AAAA;AAIN,2BAA2B,IAAI,IAAI,GAAG,YAAY,UAAU,eAAe,GAAG,GAAG,KAAK;AACpF,OAAK;AACL,OAAK;AACL,MAAI,IAAI,KAAK,KAAK,IAAI,IAAI,IAAI;AAC9B,OAAK;AACL,OAAK;AAEL,MAAI,KAAK,IAAI,IAAI;AACjB,MAAI,KAAK,IAAI,IAAI;AAEjB,MAAI,KAAK,IAAI,aAAa,YAAY,MAAM,MAAM;AAEhD,QAAI,KAAK;AACT,QAAI,KAAK;AACT,WAAO,IAAI;AAAA;AAGb,MAAI,eAAe;AACjB,QAAI,MAAM;AACV,iBAAa,gBAAgB;AAC7B,eAAW,gBAAgB;AAAA,SACtB;AACL,iBAAa,gBAAgB;AAC7B,eAAW,gBAAgB;AAAA;AAG7B,MAAI,aAAa,UAAU;AACzB,gBAAY;AAAA;AAGd,MAAI,QAAQ,KAAK,MAAM,GAAG;AAE1B,MAAI,QAAQ,GAAG;AACb,aAAS;AAAA;AAGX,MAAI,SAAS,cAAc,SAAS,YAAY,QAAQ,OAAO,cAAc,QAAQ,OAAO,UAAU;AAEpG,QAAI,KAAK;AACT,QAAI,KAAK;AACT,WAAO,IAAI;AAAA;AAGb,MAAI,KAAK,IAAI,KAAK,IAAI,cAAc;AACpC,MAAI,KAAK,IAAI,KAAK,IAAI,cAAc;AACpC,MAAI,KAAK,IAAI,KAAK,IAAI,YAAY;AAClC,MAAI,KAAK,IAAI,KAAK,IAAI,YAAY;AAClC,MAAI,KAAM,MAAK,KAAM,MAAK,KAAM,MAAK,KAAM,MAAK;AAChD,MAAI,KAAM,MAAK,KAAM,MAAK,KAAM,MAAK,KAAM,MAAK;AAEhD,MAAI,KAAK,IAAI;AACX,QAAI,KAAK;AACT,QAAI,KAAK;AACT,WAAO,KAAK,KAAK;AAAA,SACZ;AACL,QAAI,KAAK;AACT,QAAI,KAAK;AACT,WAAO,KAAK,KAAK;AAAA;AAAA;AAIrB,4BAA4B,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,KAAK,aAAa;AAClE,MAAI,KAAK,IAAI;AACb,MAAI,KAAK,IAAI;AACb,MAAI,MAAM,KAAK;AACf,MAAI,MAAM,KAAK;AACf,MAAI,UAAU,KAAK,KAAK,MAAM,MAAM,MAAM;AAC1C,SAAO;AACP,SAAO;AAEP,MAAI,eAAe,KAAK,MAAM,KAAK;AACnC,MAAI,IAAI,eAAe;AAEvB,MAAI,aAAa;AACf,QAAI,KAAK,IAAI,KAAK,IAAI,GAAG,IAAI;AAAA;AAG/B,OAAK;AACL,MAAI,KAAK,IAAI,KAAK,KAAK,IAAI;AAC3B,MAAI,KAAK,IAAI,KAAK,KAAK,IAAI;AAC3B,SAAO,KAAK,KAAM,MAAK,KAAM,MAAK,KAAM,MAAK,KAAM,MAAK;AAAA;AAG1D,4BAA4B,IAAI,IAAI,OAAO,QAAQ,GAAG,GAAG,KAAK;AAC5D,MAAI,QAAQ,GAAG;AACb,SAAK,KAAK;AACV,YAAQ,CAAC;AAAA;AAGX,MAAI,SAAS,GAAG;AACd,SAAK,KAAK;AACV,aAAS,CAAC;AAAA;AAGZ,MAAI,KAAK,KAAK;AACd,MAAI,KAAK,KAAK;AACd,MAAI,KAAK,IAAI,KAAK,KAAK,IAAI,KAAK,IAAI,GAAG,KAAK;AAC5C,MAAI,KAAK,IAAI,KAAK,KAAK,IAAI,KAAK,IAAI,GAAG,KAAK;AAC5C,SAAO,KAAK,KAAM,MAAK,KAAM,MAAK,KAAM,MAAK,KAAM,MAAK;AAAA;AAG1D,IAAI,QAAQ;AAEZ,4BAA4B,IAAI,MAAM,KAAK;AACzC,MAAI,QAAO,mBAAmB,KAAK,GAAG,KAAK,GAAG,KAAK,OAAO,KAAK,QAAQ,GAAG,GAAG,GAAG,GAAG;AACnF,MAAI,IAAI,MAAM,IAAI,MAAM;AACxB,SAAO;AAAA;AAQT,4BAA4B,IAAI,MAAM,KAAK;AACzC,MAAI,KAAK;AACT,MAAI,KAAK;AACT,MAAI,KAAK;AACT,MAAI,KAAK;AACT,MAAI;AACJ,MAAI;AACJ,MAAI,UAAU;AACd,MAAI,OAAO,KAAK;AAChB,MAAI,IAAI,GAAG;AACX,MAAI,IAAI,GAAG;AAEX,WAAS,IAAI,GAAG,IAAI,KAAK,UAAS;AAChC,QAAI,MAAM,KAAK;AAEf,QAAI,MAAM,GAAG;AACX,WAAK,KAAK;AACV,WAAK,KAAK,IAAI;AACd,WAAK;AACL,WAAK;AAAA;AAGP,QAAI,IAAI;AAER,YAAQ;AAAA,WACD,IAAI;AAGP,aAAK,KAAK;AACV,aAAK,KAAK;AACV,aAAK;AACL,aAAK;AACL;AAAA,WAEG,IAAI;AACP,YAAI,mBAAmB,IAAI,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI,GAAG,GAAG,OAAO;AAClE,aAAK,KAAK;AACV,aAAK,KAAK;AACV;AAAA,WAEG,IAAI;AACP,YAAI,kBAAkB,IAAI,IAAI,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,IAAI,KAAK,IAAI,IAAI,GAAG,GAAG;AACtG,aAAK,KAAK;AACV,aAAK,KAAK;AACV;AAAA,WAEG,IAAI;AACP,YAAI,sBAAsB,IAAI,IAAI,KAAK,MAAM,KAAK,MAAM,KAAK,IAAI,KAAK,IAAI,IAAI,GAAG,GAAG;AACpF,aAAK,KAAK;AACV,aAAK,KAAK;AACV;AAAA,WAEG,IAAI;AAEP,YAAI,KAAK,KAAK;AACd,YAAI,KAAK,KAAK;AACd,YAAI,KAAK,KAAK;AACd,YAAI,KAAK,KAAK;AACd,YAAI,QAAQ,KAAK;AACjB,YAAI,SAAS,KAAK;AAElB,aAAK;AACL,YAAI,gBAAgB,CAAC,CAAE,KAAI,KAAK;AAChC,aAAK,KAAK,IAAI,SAAS,KAAK;AAC5B,aAAK,KAAK,IAAI,SAAS,KAAK;AAE5B,YAAI,KAAK,GAAG;AAEV,eAAK;AACL,eAAK;AAAA;AAIP,YAAI,KAAM,KAAI,MAAM,KAAK,KAAK;AAE9B,YAAI,kBAAkB,IAAI,IAAI,IAAI,OAAO,QAAQ,QAAQ,eAAe,IAAI,GAAG;AAC/E,aAAK,KAAK,IAAI,QAAQ,UAAU,KAAK;AACrC,aAAK,KAAK,IAAI,QAAQ,UAAU,KAAK;AACrC;AAAA,WAEG,IAAI;AACP,aAAK,KAAK,KAAK;AACf,aAAK,KAAK,KAAK;AACf,YAAI,QAAQ,KAAK;AACjB,YAAI,SAAS,KAAK;AAClB,YAAI,mBAAmB,IAAI,IAAI,OAAO,QAAQ,GAAG,GAAG;AACpD;AAAA,WAEG,IAAI;AACP,YAAI,mBAAmB,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,OAAO;AACpD,aAAK;AACL,aAAK;AACL;AAAA;AAGJ,QAAI,IAAI,SAAS;AACf,gBAAU;AACV,UAAI,IAAI,MAAM,IAAI,MAAM;AAAA;AAAA;AAI5B,SAAO;AAAA;AAIT,IAAI,MAAM,IAAI;AACd,IAAI,MAAM,IAAI;AACd,IAAI,MAAM,IAAI;AACd,IAAI,MAAM,IAAI;AACd,IAAI,OAAO,IAAI;AASR,+BAA+B,QAAQ,gBAAgB;AAC5D,MAAI,CAAC,QAAQ;AACX;AAAA;AAGF,MAAI,YAAY,OAAO;AACvB,MAAI,QAAQ,OAAO;AAEnB,MAAI,CAAE,UAAS,YAAY;AACzB;AAAA;AAGF,MAAI,mBAAmB,OAAO,uBAAuB;AACrD,MAAI,SAAS,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG;AAClC,MAAI,cAAc,iBAAiB,cAAc;AACjD,MAAI,YAAY,MAAM,kBAAkB;AACxC,YAAU,eAAe,MAAM;AAC/B,MAAI,UAAU;AACd,MAAI,cAAc,iBAAiB;AACnC,MAAI,kBAAkB,OAAO;AAC7B,MAAI,0BAA0B,mBAAmB,OAAO,IAAI;AAC5D,MAAI,MAAM,eAAe,IAAI,cAAc;AAE3C,MAAI,aAAa;AACf,QAAI,KAAK;AAAA;AAGX,WAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC3C,QAAI,YAAY,YAAY;AAC5B,uBAAmB,WAAW,GAAG,WAAW,KAAK;AACjD,kBAAM,YAAY,KAAK,KAAK,KAAK;AAEjC,QAAI,UAAU;AAEd,QAAI,eAAe,OAAO;AAC1B,QAAI,QAAO,cAAc,YAAY,SAAS,OAAO,kBAAkB,eAAO,mBAAmB,KAAK,OAAO,MAAM,OAAO,mBAAmB,KAAK,cAAc;AAEhK,QAAI,QAAO,SAAS;AAClB,gBAAU;AAEV,UAAI,UAAU;AACd,UAAI,UAAU;AACd,UAAI,QAAQ,OAAO;AACnB,UAAI,QAAQ,OAAO;AACnB,UAAI,QAAQ,OAAO;AAAA;AAAA;AAIvB,iBAAe,QAAQ,eAAe,IAAI;AAC1C,YAAU,SAAS;AAAA,IACjB;AAAA;AAAA;AAIJ,IAAI,SAAS;AACb,IAAI,eAAe,IAAI;AAOhB,wBAAwB,YAAY,cAAc;AACvD,MAAI,CAAE,iBAAgB,OAAO,eAAe,IAAI;AAC9C;AAAA;AAGF,iBAAe,eAAe,MAAM,KAAK;AAKzC,MAAI,UAAU,WAAW;AACzB,MAAI,UAAU,WAAW;AACzB,MAAI,UAAU,WAAW;AACzB,gBAAM,IAAI,KAAK,KAAK;AACpB,gBAAM,IAAI,MAAM,KAAK;AACrB,MAAI,OAAO,IAAI;AACf,MAAI,OAAO,KAAK;AAEhB,MAAI,OAAO,QAAQ,OAAO,MAAM;AAC9B;AAAA;AAGF,MAAI,MAAM,IAAI;AACd,OAAK,MAAM,IAAI;AACf,MAAI,WAAW,IAAI,IAAI;AACvB,MAAI,kBAAkB,KAAK,IAAI;AAE/B,MAAI,kBAAkB,UAAU;AAG9B,QAAI,IAAI,mBAAmB,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,QAAQ;AAC7E,iBAAa,UAAU;AAEvB,iBAAa,YAAY,MAAM,IAAI,KAAK,IAAI,KAAK,KAAK;AAEtD,QAAI,IAAI,IAAI,MAAM,IAAI,IAAK,cAAa,IAAI,IAAI,KAAM,KAAI,IAAI,IAAI,KAAM,cAAa,IAAI,IAAI,KAAM,KAAI,IAAI,IAAI;AAE/G,QAAI,MAAM,IAAI;AACZ;AAAA;AAGF,QAAI,IAAI,GAAG;AACT,oBAAM,KAAK,cAAc;AAAA,eAChB,IAAI,GAAG;AAChB,oBAAM,KAAK,cAAc;AAAA;AAG3B,iBAAa,QAAQ,WAAW;AAAA;AAAA;AAQ7B,2BAA2B,YAAY,eAAe,iBAAiB;AAC5E,MAAI,CAAE,oBAAmB,OAAO,kBAAkB,IAAI;AACpD;AAAA;AAGF,oBAAkB,kBAAkB,MAAM,KAAK;AAC/C,MAAI,UAAU,WAAW;AACzB,MAAI,UAAU,WAAW;AACzB,MAAI,UAAU,WAAW;AACzB,gBAAM,IAAI,KAAK,KAAK;AACpB,gBAAM,IAAI,MAAM,KAAK;AACrB,MAAI,OAAO,IAAI;AACf,MAAI,OAAO,KAAK;AAEhB,MAAI,OAAO,QAAQ,OAAO,MAAM;AAC9B;AAAA;AAGF,MAAI,MAAM,IAAI;AACd,OAAK,MAAM,IAAI;AACf,MAAI,WAAW,IAAI,IAAI;AACvB,MAAI,qBAAqB,KAAK,IAAI;AAElC,MAAI,WAAW,oBAAoB;AAEjC,QAAI,IAAI,mBAAmB,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,QAAQ;AAC7E,iBAAa,UAAU;AACvB,QAAI,UAAU,KAAK,KAAK;AACxB,QAAI,SAAS,KAAK,KAAK,KAAK,IAAI;AAChC,QAAI,WAAW,UAAU,SAAS;AAElC,QAAI,YAAY,SAAS;AAEvB,oBAAM,KAAK,cAAc;AAAA,WACpB;AAEL,mBAAa,YAAY,MAAM,IAAI,KAAK,IAAI,KAAK,KAAK,IAAI;AAE1D,UAAI,IAAI,IAAI,MAAM,IAAI,IAAK,cAAa,IAAI,IAAI,KAAM,KAAI,IAAI,IAAI,KAAM,cAAa,IAAI,IAAI,KAAM,KAAI,IAAI,IAAI;AAE/G,UAAI,MAAM,IAAI;AACZ;AAAA;AAGF,UAAI,IAAI,GAAG;AACT,sBAAM,KAAK,cAAc;AAAA,iBAChB,IAAI,GAAG;AAChB,sBAAM,KAAK,cAAc;AAAA;AAAA;AAI7B,iBAAa,QAAQ,WAAW;AAAA;AAAA;AAIpC,2BAA2B,WAAW,QAAQ,WAAW,YAAY;AACnE,MAAI,WAAW,cAAc;AAC7B,MAAI,WAAW,WAAW,YAAY,UAAU,YAAY;AAE5D,WAAS,SAAS;AAElB,MAAI,SAAS,WAAW,IAAI;AAE5B,MAAI,UAAU,WAAW,MAAM;AAC7B,aAAS;AAAA;AAGX,WAAS,QAAQ,SAAS,SAAS;AAEnC,MAAI,SAAS,GAAG;AACd,aAAS,MAAM,SAAS;AAAA;AAG1B,MAAI,WAAW,WAAW,SAAS,aAAa;AAChD,aAAW,UAAU,SAAS,YAAY,SAAS,QAAQ;AAAA;AAG7D,4BAA4B,MAAM,OAAO;AACvC,MAAI,SAAS,MAAM;AACnB,MAAI,SAAS,MAAM;AAEnB,MAAI,CAAC,QAAQ;AACX;AAAA;AAGF,OAAK,OAAO,OAAO,GAAG,IAAI,OAAO,GAAG;AAEpC,MAAI,SAAS,KAAK,OAAO,UAAU,GAAG;AACpC,QAAI,OAAO,AAAO,KAAK,OAAO,IAAI,OAAO;AACzC,QAAI,OAAO,AAAO,KAAK,OAAO,IAAI,OAAO;AAEzC,QAAI,CAAC,QAAQ,CAAC,MAAM;AAClB,WAAK,OAAO,OAAO,GAAG,IAAI,OAAO,GAAG;AACpC,WAAK,OAAO,OAAO,GAAG,IAAI,OAAO,GAAG;AACpC;AAAA;AAGF,QAAI,UAAU,KAAK,IAAI,MAAM,QAAQ;AACrC,QAAI,YAAY,AAAO,KAAK,IAAI,OAAO,IAAI,OAAO,IAAI,UAAU;AAChE,QAAI,YAAY,AAAO,KAAK,IAAI,OAAO,IAAI,OAAO,IAAI,UAAU;AAChE,QAAI,YAAY,AAAO,KAAK,IAAI,WAAW,WAAW;AACtD,SAAK,cAAc,UAAU,IAAI,UAAU,IAAI,UAAU,IAAI,UAAU,IAAI,UAAU,IAAI,UAAU;AACnG,SAAK,cAAc,UAAU,IAAI,UAAU,IAAI,UAAU,IAAI,UAAU,IAAI,OAAO,GAAG,IAAI,OAAO,GAAG;AAAA,SAC9F;AACL,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,WAAK,OAAO,OAAO,GAAG,IAAI,OAAO,GAAG;AAAA;AAAA;AAAA;AASnC,2BAA2B,UAAU,cAAc,cAAc;AACtE,MAAI,YAAY,SAAS;AACzB,MAAI,QAAQ,SAAS;AAErB,MAAI,CAAC,OAAO;AAEV,QAAI,WAAW;AACb,eAAS;AAAA;AAGX;AAAA;AAGF,MAAI,cAAc,aAAa;AAC/B,MAAI,aAAa,YAAY,IAAI;AACjC,MAAI,oBAAoB,MAAM;AAE9B,WAAS,IAAI,GAAG,IAAI,eAAe,QAAQ,KAAK;AAC9C,QAAI,YAAY,eAAe;AAC/B,QAAI,aAAa,aAAa;AAC9B,QAAI,WAAW,cAAc;AAE7B,QAAI,YAAY;AACd,UAAI,YAAY,WAAW,IAAI;AAC/B,UAAI,iBAAiB,WAAW,oBAAoB,UAAU,MAAM,OAAO,cAAc,MAAM,OAAO,WAAW,QAAQ;AAEzH,UAAI,kBACD,CAAC,UAAU,WAAW,aACvB;AACE,YAAI,WAAW,WAAW,YAAY,aAAa,UAAU,OAAO;AAEpE,YAAI,UAAU;AACZ,mBAAS,SAAS;AAAA;AAGpB;AAAA;AAIJ,UAAI,CAAC,WAAW;AACd,oBAAY,IAAI;AAChB,iBAAS,iBAAiB;AAG1B,YAAI,CAAC,YAAa,sBAAqB,CAAC,aAAa;AACnD,4BAAkB,WAAW,MAAM,UAAU,aAAa;AAAA;AAI5D,YAAI,SAAS,YAAY;AACvB,oBAAU,aAAa,SAAS;AAAA;AAAA;AAIpC,wBAAkB,WAAW,OAAO,WAAW;AAAA;AAAA;AAInD,MAAI,WAAW;AACb,aAAS,UAAU,OAAO;AAE1B,cAAU,MAAM,OAAO;AACvB,QAAI,YAAY,YAAY,IAAI;AAChC,QAAI,kBAAkB,SAAS,sBAAsB,SAAS,uBAAuB;AACrF,oBAAgB,YAAY,aAAa;AAEzC,cAAU,YAAY;AAAA;AAAA;AAGnB,kCAAkC,WAAW,eAAe;AACjE,kBAAgB,iBAAiB;AACjC,MAAI,eAAe;AAAA,IACjB,QAAQ,UAAU,SAAS;AAAA;AAG7B,WAAS,IAAI,GAAG,IAAI,eAAe,QAAQ,KAAK;AAC9C,QAAI,YAAY,eAAe;AAC/B,iBAAa,aAAa,UAAU,SAAS,CAAC,WAAW;AAAA;AAG3D,SAAO;AAAA;",
  "names": []
}
